* MySQL 性能调整


* 索引

为表添加索引是提高查询性能的一个非常强大的方法。索引允许 MySQL 快速找到查询所需的数据。如果在表中添加正确的索引，查
询性能可能会提高几个数量级。诀窍在于知道要添加哪些索引。为什么不在所有列上添加索引呢？索引也会产生开销，因此在添加随机
索引之前需要分析自己的需求。

本章首先讨论什么是索引、索引的一些概念以及添加索引可能带来的弊端。然后介绍MySQL支持的各种索引类型和功能。本章的下
一部分开始讨论 InnoDB 如何使用索引，特别是与索引组织表相关的索引。最后，将讨论如何选择应该向表中添加哪些索引以及何时
添加。

** 索引是什么

为了能够使用索引来正确提高性能，了解什么是索引非常重要。本节将不讨论不同的索引类型（将在本章后面的 "索引类型 "一节
中讨论），而是介绍索引的高层次概念。

索引的概念并不新鲜，早在计算机数据库出现之前就已经存在。举个简单的例子，看看这本书。在本书的末尾，有一个索引，收录
了一些单词和术语，这些单词和术语被选为与本书文本最相关的检索词。图书索引的工作方式在概念上与数据库索引的工作方式类
似。它将数据库中的 "术语 "组织起来，这样你的查询就能比读取所有数据并检查其是否符合搜索条件更快地找到相关数据。这里
引用术语一词，是因为索引并不一定是由人类可读的单词组成的。也可以为二进制数据（如空间数据）建立索引。

简而言之，索引可以组织数据，从而缩小查询需要检查的行数。选择得当的索引可以极大地提高速度--几个数量级。再看这本书：
如果你想阅读有关 B 树索引的内容，可以从第 1 页开始阅读全书，或者在本书的索引中查找 "B 树索引 "一词，然后直接跳转
到相关页面。在查询 MySQL 数据库时，也有类似的改进，不同的是，查询可能比在书中查找相关信息要复杂得多，因此索引的重
要性也随之增加。

那么，你只需要添加所有可能的索引，对吗？不。除了添加索引的管理复杂性外，索引本身在正确使用时不仅能提高性能，还会增加
开销。因此，您需要谨慎选择索引。

另一个问题是，即使可以使用索引，它也并不总是比扫描整个表格更有效率。如果你想阅读这本书的大部分内容，那么在索引中查
找每个感兴趣的术语，找出讨论该主题的地方，然后再去阅读，最终会比从头到尾阅读整本书要慢。同样，如果您的查询无论如何
都需要访问表中的大部分数据，那么从头到尾读取整个表就会变得更快。扫描整个表会变得更便宜的阈值到底是多少，这取决于多
个因素。这些因素包括磁盘类型、顺序 I/O 与随机 I/O 相比的性能、数据是否适合内存等。

在深入探讨索引的细节之前，我们不妨先快速了解一些关键的索引概念。

** 索引概念

鉴于索引是个大话题，有几个术语用来描述索引也就不足为奇了。当然，还有一些索引类型的名称，如 B 树、全文、空间等，但
还有一些更笼统的术语需要注意。本章稍后将介绍索引类型，因此这里将讨论更一般的术语。

** key和index

您可能已经注意到，有时使用 "index"一词，有时使用 "key"一词。这两者有什么区别呢？索引是键的列表。不过，在 MySQL
语句中，这两个词经常可以互换。

在 "主键 "中，"key "就很重要--在这种情况下，必须使用 "key"。另一方面，在添加索引时，可以根据需要编写 ALTER
TABLE table_name ADD INDEX ...或 ALTER TABLE table_name ADD KEY ...。手册在这种情况下使用 "索引"，因
此为了保持一致，建议使用索引。

有几个术语可以描述你正在使用的索引类型。首先要讨论的是唯一索引。

** 唯一索引

唯一索引是指索引中的每个值只能有一条记录。考虑一个包含人员数据的表。表中可能包含个人的社会保险号或类似标识符。没有
两个人会共享社会保障号，因此在存储社会保障号的列上定义唯一索引是合理的。

从这个意义上说，"unique "更多的是指一种约束，而不是索引功能。不过，索引部分对于 MySQL 快速确定新值是否已经存在至
关重要。

在 MySQL 中使用唯一索引时的一个重要考虑因素是如何处理 NULL 值。比较两个 NULL 值是未定义的（或者换句话说，NULL
不等于 NULL），因此，允许 NULL 值的列上的唯一索引不会对列上 NULL 的行数设置任何限制。如果想限制唯一约束只允许一
个 NULL 值，可以使用触发器检查是否已经存在 NULL 值，并使用 SIGNAL 语句引发错误。触发器示例见清单

#+begin_src sql
  create table my_table(
    Id int unsigned not null,
    Name varchar(50),
    primary  key (Id),
    unique index(Name)
  );
#+end_src

#+begin_src sql
  delimiter $$
  create trigger befins_my_table
  before insert on my_table
    for each row
  begin
    declare v_errmsg, v_value text;
    if exists(select 1 from my_table where Name <=> NEW.Name) then
       if NEW.Name is null then
         set v_value='NULL';
       else
         set v_value=concat('''', NEW.Name, '''');
       end if;
         set v_errmsg=concat('Duplicate entry ',
                             v_value,
                             ' For key ''Name''');
       SIGNAL SQLSTATE '23000'
         set MESSAGE_TEXT=v_errmsg,
             MYSQL_ERRNO=1062;
     end if;
  end $$
  delimiter;
#+end_src

这将处理 Name 列的任何重复值。它使用 NULL 安全等号运算符 (<=>) 来确定 Name 的新值是否已存在于表中。如果存在，
如果值不是 NULL，则会加注引号，否则不会加注引号，因此可以区分字符串 "NULL "和 NULL 值。最后，会发出一个 SQL 状
态为 23000、MySQL 错误编号为 1062 的信号。错误信息、SQL 状态和错误编号与正常的重复键约束错误相同。

主键是一种特殊的唯一索引。

** 主键

表的主键是唯一定义记录的索引。主键绝不允许出现 NULL 值。如果表中有多个 NOT NULL 唯一索引，其中任何一个都可以作为
主键。在讨论聚类索引时，我们将解释其中的原因，因此应选择一个或多个具有不可变值的列作为主键。也就是说，以永远不更改
给定记录的主键为目标。

主键对于 InnoDB 来说是非常特殊的，而对于其他存储引擎来说，它可能只是一个约定俗成的问题。不过，在所有情况下，最好
总是有一些值可以唯一标识一条记录，例如，这样可以让复制快速确定要修改的记录（第 26 章中有更多相关内容），而且组复制
功能明确要求所有表都必须有一个主键或一个非 NULL 唯一索引。在 MySQL 8.0.13 及更高版本中，可以启用
sql_require_primary_key 选项，要求所有新表必须有主键。如果更改现有表的结构，该限制也同样适用。

#+begin_comment
  启用 sql_require_primary_key 选项（默认已禁用）。没有主键的表可能会导致性能问题，有时会以意想不到的微妙方式
  出现。
#+end_comment

如果有主键，是否还有次键？

** 二级索引

二级索引 "一词用于指不是主键的索引。它没有任何特殊含义，因此使用这个名称只是为了明确说明，无论该索引是唯一索引还是
非唯一索引，它都不是主键。

如前所述，主键对 InnoDB 有特殊意义，因为它用于聚类索引。

** 聚类索引

聚类索引是 InnoDB 特有的，是 InnoDB 组织数据的术语。如果你熟悉 Oracle DB，你可能知道索引组织表；这描述的是同样
的事情。

InnoDB 中的一切都是索引。行数据位于 B 树索引的叶页中（B 树索引稍后会介绍）。该索引称为聚类索引。这个名称源于索引
值被聚类在一起。聚类索引使用主键。如果没有指定明确的主键，InnoDB 将查找不允许 NULL 值的唯一索引。如果该索引不存在，
InnoDB 将添加一个隐藏的 6 字节整数列，使用全局（适用于所有 InnoDB 表）自动递增值来生成唯一值。

主键的选择对性能也有影响。本章后面的 "索引策略 "一节将讨论这些问题。聚类索引也可以看作是覆盖索引的一种特例。这是什
么呢？你马上就会知道。

** 覆盖索引

如果一个索引包含了特定查询所需的索引表中的所有列，那么这个索引就是覆盖索引。也就是说，索引是否覆盖取决于使用索引进
行的查询。一个索引可能对一个查询是覆盖索引，但对另一个查询却不是。考虑一个索引（a, b）和一个选择这两列的查询：

#+begin_src sql
  select a, b
    from my_table
   where a=10;
#+end_src

在这种情况下，查询只需要 a 列和 b 列，因此不需要查找行的其他部分--索引足以检索到所有需要的数据。另一方面，如果查
询还需要列 c，索引就不再起作用了。当使用 EXPLAIN 语句分析查询时（第 20 章将介绍），如果表使用了覆盖索引，那么
EXPLAIN 输出中的 Extra 列将包含 "Using Index"。

InnoDB 的聚类索引是覆盖索引的一个特例（尽管 EXPLAIN 不会显示 "Using Index"）。聚类索引包括叶节点中的所有行数
据（尽管一般情况下只有列的子集被实际索引），因此索引将始终包括所有需要的数据。某些数据库在创建索引时支持 include
子句，可用于模拟聚类索引的工作方式。

巧妙地创建索引，将其用作执行次数最多的查询的覆盖索引，可以大大提高性能，"索引策略 "部分将对此进行讨论。

添加索引时，需要遵守一些限制。接下来要介绍的就是这些限制。

** 索引限制

InnoDB 索引有一些限制。这些限制从索引大小到表允许的索引数量不等。最重要的限制如下：

+ B 树索引的最大宽度为 3072 字节或 767 字节，具体取决于 InnoDB 行格式。最大大小基于 16 kiB InnoDB 页面，对
  于较小的页面大小，限制会更低。

+ 只有在指定了前缀长度的情况下，Blob 和文本类型列才能在索引（全文本索引除外）中使用。本章稍后将在 "索引功能 "一节
  中讨论前缀索引。

+ 功能键部分计入表格 1017 列的限制内。

+ 每个表最多可以有 64 个二级索引。

+ 多列索引最多可包括 16 列和功能键部分。


您可能会遇到的限制是 B 树索引的最大索引宽度。使用 DYNAMIC（默认）或 COMPRESSED 行格式时，索引宽度不能超过 3072
字节；使用 REDUNDANT 和 COMPACT 行格式时，索引宽度不能超过 767 字节。使用 DYNAMIC 和 COMPRESSED 行格式的表，
8 KiB 页面的限制减少到一半（1536 字节），4 KiB 页面的限制减少到四分之一（768 字节）。这对字符串和二进制列索引的
限制尤为明显，因为这些值不仅在本质上通常较大，而且在计算大小时使用的也是可能需要的最大存储量。这意味着，使用
utf8mb4 字符集的 varchar(10) 会导致 40 字节的限制，即使您从未在列中以单字节字符存储任何内容。

在为文本或 blob 类型的列添加 B 树索引时，必须始终提供一个键长度，指定要在索引中包含多少列的前缀。这甚至适用于只支
持 256 字节数据的 tinytext 和 tinyblob。对于 char、varchar、二进制和 varbinary 列，只有在值的最大字节数超
过表允许的最大索引宽度时，才需要指定前缀长度。

#+begin_comment
  对于文本和 blob 类型的列，与其使用前缀索引，不如使用全文索引（稍后详述），或者添加一个包含 blob 哈希值的生成
  列，或者以其他方式优化访问。
#+end_comment

如果为表添加功能索引，则每个功能键部分都会计入表的列限制。如果创建的索引有两个功能部分，那么这两个功能部分将作为两
列计算到表的限制中。对于 InnoDB，一个表最多只能有 1017 列。

最后两个限制与表中可包含的索引数量以及单个索引中可包含的列和功能键部分的数量有关。一个表最多可以有 64 个二级索引。
在实际操作中，如果您已经接近这个限制，那么您可能需要重新考虑您的索引策略。本章后面的 "索引的缺点是什么？"中将讨论
索引的开销，因此在任何情况下，最好将索引的数量限制在真正有利于查询的范围内。同样，向索引添加的部分越多，索引的规模
就越大。InnoDB 的限制是最多只能添加 16 个部分。

如果需要为表添加索引或删除多余的索引，该怎么办？索引可以与表一起创建，也可以稍后创建，还可以删除索引，这将在下文中
讨论。

** SQL语法

在首次创建模式时，您一般会有一些添加索引的想法。随着时间的推移，您的监控可能会发现某些索引已不再需要，而应添加其他
索引。这些对索引的更改可能是由于对所需索引的误解；数据可能已经更改，或者查询可能已经更改。

在更改表的索引时，有三种不同的操作：在创建表时创建索引、为现有表添加索引或从表中删除索引。无论是与表一起添加索引，
还是作为后续操作添加索引，索引定义都是一样的。在删除索引时，只需要索引名称。

本节将介绍添加和删除索引的一般语法。在本章的其余部分，将根据特定的索引类型和功能进一步举例说明。

** 创建表时创建索引

创建表格时，可以在 CREATE TABLE 语句中添加索引定义。索引定义在列之后。您可以选择指定索引的名称；如果不指定，索
引将以索引中的第一列命名。

清单 14-2 显示了一个创建了多个索引的表的示例。如果不知道所有索引类型的作用，也不必担心，本章稍后将讨论这个问题。

#+begin_src sql
  create table db1.person(
    Id int unsigned not null,
    Nmae varchar(50),
    Birthdate date not null,
    Location point not null srid 4326,
    Description text,
    primary key(Id),
    index (Nmae),
    spatial index (Location),
    fulltext index(Description)
  );
#+end_src

这样就在 db1 模式（必须事先存在）中创建了带有四个索引的表 person。第一个是主键，它是一个 B 树索引（稍后将详细介
绍），指向 Id 列。第二个也是 B 树索引，但它是所谓的二级索引，索引 Name 列。第三个索引是位置列上的空间索引。第四个
索引是描述列上的全文索引。

您还可以创建一个包含多列的索引。如果需要在不止一列上设置条件，在第一列上设置条件并按第二列排序，等等，这将非常有用。
要创建多列索引，请用逗号分隔的列表指定列名：

#+begin_src sql
  INDEX(Name, Birthdate)
#+end_src

列的顺序非常重要，这将在 "索引策略 "中解释。简而言之，MySQL 只能使用从左边开始的索引，也就是说，只有同时使用 Name
时，才能使用索引的 Birthdate 部分。这意味着索引（Nmae，Birthdate）与（Birthdate，Name）不是同一个索引。

一般来说，表上的索引不会一成不变，那么如果要为现有表添加索引，该怎么办呢？


** 新增索引

如果确定需要，可以为现有表添加索引。为此，需要使用 ALTER TABLE 或 CREATE INDEX 语句。由于 ALTER TABLE 语句
可用于表的所有修改，因此您可能希望坚持使用该语句；不过，无论使用哪种语句，所做的工作都是一样的。

清单 14-3 显示了两个如何使用 ALTER TABLE 创建索引的示例。第一个示例添加了一个索引；第二个示例在一条语句中添加了
两个索引。

#+begin_src sql
  alter table db1.person
    add index (Birthdate);

  alter table db1.person
    drop index Birthdate;

  alter table db1.person
    add index (Nmae, Birthdate),
    add index (Birthdate);
#+end_src

第一条和最后一条 ALTER TABLE 语句使用 ADD INDEX 子句告诉 MySQL 应该向表中添加索引。第三条语句添加了两个这样
的子句，中间用逗号隔开，以便在一条语句中添加两个索引。在这两条语句之间，索引会被删除，因为拥有重复索引是不好的做法，
MySQL 也会对此提出警告。

用两条语句添加两个索引还是用一条语句添加两个索引有区别吗？是的，可能会有很大区别。添加索引时，有必要执行一次全表扫
描，以读取索引所需的所有值。对于大型表来说，全表扫描是一项昂贵的操作，因此从这个意义上说，最好在一条语句中同时添加
两个索引。另一方面，只要索引能完全保存在 InnoDB 缓冲池中，创建索引的速度就会快很多。将两个索引的创建分成两条语句，
可以减少缓冲池的压力，从而提高索引创建性能。

最后一项操作是删除不再需要的索引。

** 删除索引

删除索引的操作与添加索引类似。可以使用 ALTER TABLE 或 DROP INDEX 语句。使用 ALTER 表时，可以将删除索引与表的
其他数据定义操作结合起来。

#+begin_src sql
  show create table db1.person\G
#+end_src

#+begin_src sql
  select INDEX_NAME, INDEX_TYPE,
    GROUP_CONCAT(COLUMN_NAME ORDER BY SEQ_IN_INDEX) as Columns
  from information_schema.STATISTICS
  where TABLE_SCHEMA='db1'
    and TABLE_NAME='person'
  group by INDEX_NAME, INDEX_TYPE;
#+end_src

在您的情况下，索引可能以不同的顺序列出。第一个查询使用 SHOW CREATE TABLE 语句获取完整的表定义，其中也包括索引及
其名称。第二个查询是查询 information_schema。STATISTICS 视图。该视图对于获取索引信息非常有用，将在下一章详细
讨论。一旦决定要删除哪个索引，就可以使用清单 14-5 所示的 ALTER TABLE。

#+begin_src sql
  alter table db1.person drop index name_2;
#+end_src

这将删除名为 name_2 的索引，即（Name、Birthdate）列上的索引。

本章其余部分将详细介绍什么是索引，在本章末尾，"索引策略 "一节将讨论如何选择要索引的数据。首先，必须了解索引为什么会
产生开销。

** 指数有哪些缺点？

生活中很少有免费的东西，索引也不例外。虽然索引对提高查询性能很有帮助，但它们也需要存储并保持更新。此外，在执行查询
时，索引越多，优化器需要做的工作就越多，这是一个不太明显的开销。本节将介绍索引的这三个缺点。

*** 存储

添加索引最明显的代价之一是需要存储索引，以便在需要时随时可用。 存储开销有两方面：索引需要存储在磁盘上以保持其持久性，
同时还需要 InnoDB 缓冲池中的内存以供查询使用。

磁盘存储意味着你可能需要在系统中添加磁盘或块存储。 如果使用 MySQL Enterprise Backup (MEB) 等复制原始表空间文
件的备份解决方案，备份也会变大，完成时间也会变长。

InnoDB 总是使用缓冲池来读取查询所需的数据。 如果缓冲池中还不存在数据，则会先将其读入缓冲池，然后用于查询。因此，
使用索引时，索引和行数据一般都会被读入缓冲池（使用覆盖索引时例外）。需要放入缓冲池的数据越多，其他索引和数据的空间
就越小--除非你把缓冲池的容量增大。当然，情况要比这复杂得多，因为避免全表扫描还能防止将整个表读入缓冲池，从而减轻缓
冲池的压力。总体收益与开销之间的关系取决于使用索引可以避免检查多少表，以及其他查询是否会读取索引避免访问的数据。

总而言之，在添加索引时，你将需要额外的磁盘，而且一般来说，你将需要更大的 InnoDB 缓冲池来保持相同的缓冲池命中率。
另一个开销是，索引只有在保持更新时才有用。这就增加了更新数据时的工作量。

*** 更新索引

无论何时对数据进行更改，都必须更新索引。 这包括在插入或删除数据时添加或删除行链接，以及在更新值时修改索引。你可能
不会太在意这些，但这可能会造成很大的开销。事实上，在恢复逻辑备份（通常包括用于创建数据的 SQL 语句的文件，例如使用
mysqlpump 程序创建的文件）等批量数据加载过程中，保持索引更新的开销往往会限制插入率。

#+begin_comment
  更新索引的开销可能会非常大，因此一般建议在向空表进行大型导入时删除二级索引，然后在导入完成后重新创建索引。
#+end_comment

对于 InnoDB 来说，开销还取决于二级索引是否适合缓冲池。只要整个索引都在缓冲池中，那么更新索引的成本就相对较低，而且
也不太可能成为严重的瓶颈。如果索引无法容纳，InnoDB 就不得不在表空间文件和缓冲池之间不停地洗页，这时开销就会成为主
要瓶颈，导致严重的性能问题。

还有一个不太明显的性能开销。索引越多，优化器确定最佳查询计划的工作量就越大。

*** 优化器

当优化器分析查询以确定它认为的最优查询执行计划时，它需要评估每个表上的索引，以确定是否应该使用索引，以及是否对两
个索引进行索引合并。我们的目标当然是尽可能快地评估查询。但是，在优化器中花费的时间通常是不可忽略的，在某些情况下
甚至会成为瓶颈。

请看一个非常简单的查询示例，从一个表中选择一些行：

#+begin_src sql
  select ID, Nmae District, Population
    from world.city
  where CountryCode='AUS';
#+end_src

在这种情况下，如果表 city 上没有索引，显然需要进行表扫描。如果有一个索引，还需要评估使用索引的查询成本，等等。
如果您有一个复杂的查询，涉及许多表，每个表都有十几个可能的索引，那么就会产生许多组合，这将反映在查询的执行时间上。

#+begin_comment
  如果在优化器中花费的时间成为问题，可以添加第 17 章和第 24 章中讨论的优化器和连接顺序提示来帮助优化器，这样它
  就不需要评估所有可能的查询计划。
#+end_comment

虽然这些描述添加索引的开销的页面会让人觉得索引不好，但不要回避索引。对于频繁执行的查询，选择性强的索引会带来很大
的好处。但是，不要为了添加索引而添加索引。在本章末尾的 "索引策略 "一节中，我们将讨论选择索引的一些思路，本书的其
他部分也会有讨论索引的示例。在此之前，值得讨论一下 MySQL 支持的各种索引类型以及其他索引功能。

** 索引类型

索引的最佳类型并非适用于所有用途。为查找给定值范围（例如 2019 年的所有日期）内的行而优化的索引，与为给定单词或短
语搜索大量文本的索引，需要有很大的不同。这意味着在选择添加索引时，必须决定需要哪种索引类型。MySQL 目前支持五种不
同的索引类型：

+ B树索引
+ 全文索引
+ 地理索引(R树索引)
+ 多值索引
+ hash索引

本节将介绍这五种索引类型，并讨论它们可用于加速哪些类型的问题。

*** B树索引

到目前为止，B 树索引是 MySQL 中最常用的索引类型。事实上，所有 InnoDB 表都包含至少一个 B 树索引，因为数据是在
B 树索引（聚类索引）中组织的。

B 树索引是一种有序索引，因此它善于查找以下情况的记录：正在查找等于某个值的列，大于或小于给定值的列，或者介于两个
值之间的列。这使它成为许多查询中非常有用的索引。

B 树索引的另一个优点是性能可预测。顾名思义，索引就像一棵树，从根页面开始，到叶子页面结束。InnoDB 使用 B 树索引
的扩展，称为 B+ 树。+"的意思是同级的节点是链接的，因此在扫描索引时很方便，无需在到达某个节点的最后一条记录时再返
回到父节点。

#+begin_comment
  在 MysQL 中，B-树和 B+ 树这两个术语可以互换使用。
#+end_comment

城市名称索引的索引树示例见图 14-1。(图中的索引级别从左到右排列，与其他一些 B 树索引图示从上到下的排列方式不同
）。这样做主要是为了节省空间）。

[[./images/1BmL8f.png]]

在图中，文档形状代表一个 InnoDB 页面，多个文档堆叠在一起的形状（如第 0 层中标注为 "Christchurch "的文档）代
表多个页面。从左到右的箭头从根页面指向叶页面。根页面是索引搜索开始的地方，而叶页面则是索引记录存在的地方。介于两
者之间的页面通常称为内部页面或分支页面。页面也可称为节点。连接同级页面的双箭头是 B 树和 B+ 树索引的区别所在，它
允许 InnoDB 快速移动到上一个或下一个同级页面，而无需通过父页面。

对于小型索引，可能只有一个页面既是根页面又是叶页面。在更一般的情况下，索引有一个根页面，如图的最左边所示。图中最
右边的部分是叶页。对于大型索引，中间可能还有更多级。叶节点为 0 级，其父页为 1 级，依此类推，直到根页。

在图中，页面上标注的值，例如 "A Coruña"，表示树的该部分所涵盖的第一个值。因此，如果您在第 1 层查找值
"Adelaide"，您就会知道它在叶页的最顶层，因为该页包含了从 "A Coruña "开始到最后一个值 "Beijing "之前的所有
值。这就是上一章讨论的整理方法发挥作用的一个例子。

一个主要特点是，无论你遍历哪个分支，层级的数量总是相同的。例如，在图中，这意味着无论查找哪个值，都将读取四个页面，
四个层级各一个（如果有几行具有相同的值，对于范围扫描，可能会读取叶子层级的更多页面）。因此，可以说这棵树是平衡的。
正是这一特性带来了可预测的性能，而且层级数量扩展良好，也就是说，层级数量会随着索引记录数量的增加而缓慢增长。当需
要从磁盘等相对较慢的存储设备中访问数据时，这一特性尤为重要。

#+begin_comment
  您可能也听说过 T树索引。B 树索引针对磁盘访问进行了优化，而 T树索引与 B 树索引类似，只是针对内存访问进行了优
  化。因此，将所有索引数据存储在内存中的 NDBCluster 存储引擎使用 T 树索引，即使它们在 SQL 级别被称为 B 树索引。
#+end_comment

本节开头提到，B 树索引是迄今为止 MySQL 中最常用的索引类型。事实上，如果你有任何 InnoDB 表，即使你从未自己添加
过任何索引，你也在使用 B 树索引。InnoDB 使用聚类索引组织存储数据，这实际上意味着行存储在 B+ 树索引中。B树索引
也不只用于关系数据库，例如，一些文件系统就以B树结构组织元数据。

需要注意的是，B 树索引的一个特性是只能用于比较索引列的整个值或左前缀。这意味着，如果要检查索引日期的月份是否为
5 月，则不能使用索引。如果要检查索引字符串是否包含给定的短语，也是同样的道理。

在索引中包含多列时，同样的原则也适用。考虑索引（Name, Birthdate）：在这种情况下，您可以使用该索引搜索给定的姓
名或姓名和生日的组合。但是，在不知道姓名的情况下，您不能使用该索引搜索具有给定生日的人。

有几种方法可以处理这种限制。在某些情况下，可以使用功能索引，或者将列的信息提取到可以编制索引的生成列中。在其他情
况下，可以使用另一种索引类型。例如，全文索引可用于搜索字符串中包含 "查询性能调整 "短语的列。

** 全文索引

全文索引专门用于回答 "哪个文档包含这个字符串？"这样的问题。也就是说，全文索引在查找列与字符串完全匹配的行时并没有
进行优化，为此，B 树索引是更好的选择。

全文索引的工作原理是对被索引的文本进行标记化。具体方法取决于所使用的解析器。InnoDB 支持使用自定义解析器，但通常使
用内置解析器。默认解析器假定文本使用空白作为分隔符。MySQL 包含两个可选的解析器：支持中文、日文和韩文的 ngram 解
析器和支持日文的 MeCab 解析器。

InnoDB 使用名为 FTS_DOC_ID 的特殊列将全文索引链接到记录，该列是一个 bigint 无符号 NOT NULL 列。如果添加了全
文索引，而该列还不存在，InnoDB 会将其添加为隐藏列。添加隐藏列需要重建表，因此如果要为大型表添加全文索引，需要考虑
到这一点。如果知道要在表中使用全文索引，可以事先自己添加列，并为列添加唯一索引 FTS_DOC_ID_INDEX。您也可以选择使
用 FTS_DOC_ID 列作为主键，但要注意 FTS_DOC_ID 值不允许重复使用。自己准备表的示例如下：

#+begin_src sql
  drop table if exists db1.person;

  create table db1.person(
    FTS_DOC_ID bigint unsigned not null auto_increment,
    Nmae varchar(50),
    Description text,
    primary key (FTS_DOC_ID),
    fulltext index(Description)
  );
#+end_src

如果没有 FTS_DOC_ID 列，并且在现有表中添加了一个全文本列，MySQL 将返回一个警告，告知该表已被重建以添加该列：

Warning (code 124): InnoDB rebuilding table to add column FTS_DOC_ID

如果计划使用全文索引，建议从性能角度明确添加 FTS_DOC_ID 列，并将其设置为表的主键或为其创建辅助唯一索引。自己创建
列的缺点是必须自己管理值。

另一种专门的索引类型是空间数据索引。全文索引适用于文本文档（或字符串），而空间索引则适用于空间数据类型。

** 空间索引（R 树）

从历史上看，空间特性在 MySQL 中的使用并不多。不过，随着 InnoDB 在 5.7 版中支持空间索引，以及 MySQL 8 中支持为
空间数据指定空间参考系统标识符 (SRID) 等其他改进，您有可能在某些时候需要空间索引。

空间索引的一个典型用例是包含兴趣点的表格，每个兴趣点的位置与其他信息一起存储。例如，用户可能会要求获取其当前位置 50
公里范围内的所有电动汽车充电站。要尽可能高效地回答这样的问题，就需要空间索引。

MySQL 以 R 树的形式实现空间索引。R 代表矩形，暗示了索引的用途。R 树索引对数据进行组织，使空间上相近的点在索引中
存储得很近。这样就能有效确定空间值是否满足某些边界条件（如矩形）。

只有在列声明为 NOT NULL 且空间参照系统标识符已设置的情况下，才能使用空间索引。空间条件是通过 MBRContains() 等
函数之一指定的，该函数接收两个空间值，并返回第一个值是否包含另一个值。除此之外，使用空间索引没有特殊要求。清单 14-6
显示了一个带有空间索引的表和一个可以使用该索引的查询的示例。

#+begin_src sql
  create table db1.city(
     id int unsigned not null,
     Nmae varchar(50) not null,
     Location point SRID 4326 not null,
     primary key (id),
     spatial index(Location));

  insert into db1.cty
  values (1, 'Sydney',
          ST_GeomFromText('Point(-33.8650 151.2094)', 4326));

  set @boundary=ST_GeomFromText('Polygon((-9 112, -45 112, -45 160,
      -9 160, -9 113))', 4326);

  select id, Name
    from db1.city
  where MBRContains(@boundary, Location);
#+end_src

在示例中，一个包含城市位置的表在位置列上有一个空间索引。空间参照系统标识符 (SRID) 设置为 4326，以表示地球。在这
个示例中，插入了一条记录，并定义了一个边界（如果你很好奇，那么边界包含澳大利亚）。您也可以在 MBRContains() 函数
中直接指定多边形，但这里分两步进行，以便查询的各个部分更加清晰。

因此，空间索引有助于回答某个几何形状是否在某个边界内。同样，多值索引也能帮助回答给定值是否在值列表中。

** 多值索引

MySQL 在 MySQL 5.7 中引入了对 JSON 数据类型的支持，并在 MySQL 8 中通过 MySQL 文档存储扩展了该功能。您可以使
用生成列上的索引或功能索引来创建 JSON 文档上的索引；但是，迄今为止讨论的索引类型未涵盖的一种用例是搜索 JSON 数组
包含某些值的文档。例如，一个城市集合，每个城市都有一个郊区数组。上一章中的 JSON 文档示例就是这样：

#+begin_src js
  {
      "name":
      "Sydney",
      "demographics": { "population": 5500000 },
      "geography": { "country": "Australia", "state": "NSW" },
      "suburbs": [ "The Rocks", "Surry Hills", "Paramatta" ]
  }
#+end_src

如果您想搜索城市集合中的所有城市，并返回那些拥有名为 "Surry Hills "的郊区的城市，那么您需要一个多值索引。
MySQL 8.0.17 增加了对多值索引的支持。

解释多值索引如何有用的最简单方法是看一个示例。清单 14-7 从 world_x 示例数据库中提取了 countryinfo 表，将其复
制到 mvalue_index 表中，然后对其进行修改，使每个 JSON 文档都包含一个城市数组，其中包含城市人口和所在地区。最后，
还包含一个查询，以显示检索澳大利亚所有城市名称（_id = 'AUS'）的示例。本书 GitHub 代码库中的 listing_14_7.sql
文件也提供了这些查询，可以使用 \source listing_14_7.sql 命令在 MySQL Shell 中执行。

#+begin_src sql
  \use world_x

  drop table if exists mvalue_index;

  create table mvalue_index like countryinfo;

  insert into mvalue_index(doc)
    select doc
      from countryinfo;

  update mvalue_index
    set doc=JSON_INSERT(
    doc,
    '$.cities',
    (select JSON_ARRAYAGG(
             JSON_OBJECT(
             'district', district,
             'name', name,
             'population',
                  Info->'$.Population'
           )
          )
         from city
        where CountryCode=mvalue_index.doc->>'$.Code'
       )
  );
#+end_src

#+begin_src sql
  select JSON_PRETTY(doc->>'$.cities[*].name')
    from mvalue_index
    where doc->>'$.Code'='AUS'\G
#+end_src

列表首先将 world_x 模式设为默认模式，然后删除存在的 mvalue_index 表，并使用与 countryinfo 表相同的定义和相同
的数据再次创建该表。您也可以直接修改 countryinfo 表，但通过处理 mvalue_index 副本，您可以通过删除
mvalue_index 表轻松重置 world_x 模式。该表由名为 doc 的 JSON 文档列和名为 _id 的生成列（主键）组成：

#+begin_src sql
  show create table mvalue_index\G
#+end_src

UPDATE 语句使用 JSON_ARRAYAGG() 函数为每个国家创建一个包含三个 JSON 对象（地区、名称和人口）的 JSON 数组。
最后，执行 SELECT 语句返回澳大利亚城市的名称。

现在能为城市名新增多值索引

#+begin_src sql
  alter table mvalue_index
    add index (((cast(doc->>'$.cities[*].name' as char(35) array))));
#+end_src

该索引从文档根部的城市数组的所有元素中提取名称对象。生成的数据被转换为 char(35) 值数组。之所以选择这种数据类型，
是因为城市名称所在的城市表是 char(35)。在 CAST() 函数中，char 和 varchar 数据类型都使用 char。

新索引可以使用 MEMBER OF 操作符和 JSON_CONTAINS() 与 JSON_OVERLAPS() 函数用于 WHERE 子句。MEMBER OF 操
作符询问给定值是否是数组的成员。JSON_CONTAINS() 与此非常相似，但与 MEMBER OF 的引用搜索相比，它需要进行范围搜
索。JSON_OVERLAPS() 可用于查找包含多个值中至少一个值的文档。清单 14-8 展示了使用操作符和每个函数的示例。

#+begin_src sql
  select doc->>'$.Code' as Code, doc->>'$.Nmae'
  from mvalue_index
  where 'Sydeney' member of (doc->'$.cities[*].name');

  select doc->>'$.Code' as Code, doc->>'$.Name'
  from mvalue_index
  where JSON_CONTAINS(
    doc->'$.cities[*].name',
    '"Sydeney"'
  );

  select doc->>'$.Code' as Code, doc->>'$.Name'
  from mvalue_index
  where JSON_OVERLAPS(
    doc->'$.cities[*].name',
    '["Sydeney", "New York"']'
  );
#+end_src

使用 MEMBER OF 和 JSON_CONTAINS() 的两个查询都是查找有一个名为悉尼的城市的国家。最后一个查询使用
JSON_OVERLAPS()，查找城市名为悉尼或纽约或两者都有的国家。

MySQL 还剩下一种索引类型：散列索引。

** hash索引

如果要搜索某列与某个值完全相等的记录，可以使用本章前面讨论过的 B 树索引。不过还有另一种方法：为每一列的值创建一个
哈希值，然后使用哈希值搜索匹配的记录。为什么要这样做呢？答案是，这是一种查找记录的快速方法。

散列索引在 MySQL 中使用不多。一个值得注意的例外是 NDBCluster 存储引擎，它使用散列索引来确保主键和唯一索引的唯一
性，还使用散列索引来提供使用这些索引的快速查找。就 InnoDB 而言，它并不直接支持散列索引；不过，InnoDB 有一种称为
自适应散列索引的功能，值得我们多加考虑。

自适应哈希索引功能在 InnoDB 中自动运行。如果 InnoDB 检测到你正在频繁使用二级索引，并且自适应散列索引已启用，它
就会根据最频繁使用的值建立一个散列索引。哈希索引只存储在缓冲池中，因此在重启 MySQL 时不会持久化。如果 InnoDB 发
现内存可以更好地用于向缓冲池加载更多页面，它就会丢弃部分哈希索引。这就是所谓自适应索引的意思： InnoDB 会尝试调整
它，使其最适合你的查询。你可以使用 innodb_adaptive_hash_index 选项启用或禁用该功能。

从理论上讲，自适应散列索引是一种双赢方案。你无需考虑需要为哪些列添加哈希索引，就能获得哈希索引的优势，而且内存使用
情况也会自动得到处理。不过，启用哈希索引也会产生开销，而且并非所有工作负载都能从中受益。事实上，对于某些工作负载来
说，这种开销可能会变得非常大，以至于出现严重的性能问题。

监控自适应散列索引有两种方法：信息模式中的 INNODB_METRICS 表和 InnoDB 监控器。INNODB_METRICS 表包含自适应散
列索引的八个指标，其中两个指标默认已启用。清单 14-9 显示了 INNODB_METRICS 中包含的八个指标。

#+begin_src sql
  select NAME, COUNT, STATUS, COMMENT
  from information_schema.INNODB_METRICS
  where SUBSYSTEM='adaptive_hash_index'\G
#+end_src

使用自适应哈希索引的成功搜索次数（adaptive_hash_searches）和使用 B 树索引完成的搜索次数
（adaptive_hash_searches_btree）默认是启用的。你可以使用这些指标来确定 InnoDB 使用哈希索引解决查询的频率，
而不是底层 B 树索引。其他指标不太常用，因此默认禁用。不过，如果你想更详细地了解自适应哈希索引的用处，可以放心地启
用这六个指标。

监控自适应哈希索引的另一种方法是使用 InnoDB 监控，如清单 14-10 所示。输出中的数据会有所不同。

#+begin_src sql
  show engine inoodb status\G
#+end_src

首先要检查的是 Semaphores 部分。如果自适应散列索引是竞争的主要来源，那么 btr0sea.ic 文件（源代码中实现自适应散
列索引的地方）周围就会出现 Semaphores。如果偶尔（但很少）会出现 Semaphores，这不一定是个问题，但如果频繁出现长
时间的 Semaphores，则最好禁用自适应散列索引。

另一个值得关注的部分是插入缓冲区和自适应哈希索引部分。其中包括散列索引使用的内存量，以及使用散列和非散列搜索回答查
询的速率。请注意，这些速率针对的是监视器输出顶部附近列出的时间段--在示例中，针对的是 2019-05-05 17:22:14 之前
的最后 16 秒。

关于支持的索引类型的讨论到此结束。关于索引，还有更多的内容，因为有几项功能值得你去熟悉。

** 索引特性

知道存在哪些类型的索引是一回事，但能够充分利用这些索引则是另一回事。为此，你需要更多地了解 MySQL 中与索引相关的
功能。这些功能包括按相反顺序对索引中的值进行排序、功能索引和自动生成索引。本节将介绍这些功能，以便您在日常工作中使
用它们。

** 函数索引

到目前为止，索引已直接应用于列。这是最常见的添加索引方式，但也有需要使用派生值的情况。例如，查询所有生日在 5 月份
的人：

#+begin_src sql
  drop table if exists db1.person;

  create table db1.person(
    Id int unsigned not null,
    Name varchar(50),
    Birthdate date not null,
    primary key (id)
  );

  select *
    from db1.person
    where month(Birthdate) = 5;
#+end_src

如果在 "出生日期 "列上添加索引，则不能用于回答该查询，因为日期是根据其完整值存储的，而不是根据列的最左部分进行匹配
（另一方面，搜索所有 1970 年出生的人可以使用 "出生日期 "列上的 B 树索引）。(另一方面，要搜索所有 1970 年出生的
人，可以在 Birthdate 列上使用 B 树索引）。

其中一种方法是用派生值生成一列。例如，在 MySQL 5.7 及更高版本中，您可以告诉 MySQL 自动更新列：

#+begin_src sql
  create table db1.person(
    Id int unsigned not null,
    Name varchar(50) not null,
    Birthdate date not null,
    BirthMonth tinyint unsigned
              generated always as (month(Birthdate))
              virtual not null,
    primary key(Id),
    index(BirthMonth)
  );
#+end_src

在 MySQL 8.0.13 中，有一种更直接的方法可以实现这一目标。您可以直接索引函数的结果：

#+begin_src sql
  create table db1.person(
    Id int unsigned not null,
    Name varchar(50) not null,
    Birthdate date not null,
    primary key (Id),
    index((month(Birthdate)))
  );
#+end_src

使用功能索引的好处是可以更明确地显示要索引的内容，而且不会多出 BirthMonth 列。除此之外，添加函数索引的两种方法工
作原理相同。

** 前缀索引

表的索引部分大于表数据本身的情况并不少见。如果你索引的是大字符串值，情况尤其如此。B 树索引的索引数据最大长度也有限
制--使用动态或压缩行格式的 InnoDB 表为 3072 字节，其他表则更小。这实际上意味着不能为文本列建立索引，更不用说长
文本列了。减少大型字符串索引的一种方法是只索引值的第一部分。这就是所谓的前缀索引。

创建前缀索引时，需要指定要索引的字符串的字符数或二进制对象的字节数。如果要为城市表（来自世界数据库）中 Name 列的前
十个字符创建索引，可以这样做

#+begin_src sql
  alter table world.city add index(Name(10));
#+end_src

请注意括号中添加的索引字符数。只要选择足够多的字符来提供良好的选择性，该索引的效果几乎与索引整个名称一样好，而且它
使用的存储空间和内存也更少。需要包含多少字符？这完全取决于您要索引的数据。您可以通过查询数据来了解前缀的唯一性。清
单 14-11 举例说明了有多少城市名称共享前十个字符。

#+begin_src sql
  select left(Name, 10), count(*),
    count(distinct Name) as 'Distinct'
  from world.city
  group by left(Name, 10)
  order by count(*) desc, left(Name, 10)
  limit 10;
#+end_src

这表明，使用这个索引前缀，最多只能读取 6 个城市来查找匹配。虽然这比完全匹配要多，但仍比扫描所有表格要好得多。当然，
在这种比较中，您还需要验证前缀匹配的数量是由于前缀碰撞造成的，还是由于城市名称相同造成的。例如，对于 "剑桥 "来说，
有三个城市都叫这个名字，所以索引前十个字符还是整个名字并没有什么区别。您可以针对不同的前缀长度进行此类分析，以了解
增加索引大小会带来微小回报的临界值。在很多情况下，索引并不需要那么多字符就能很好地工作。

如果您认为可以删除索引，或者您想推出一个索引，但又不想让它立即生效，该怎么办呢？
答案就是隐形索引。

** 隐形索引

MySQL 8 引入了一项名为 "隐形索引 "的新功能。它允许你拥有一个已维护并可随时使用的索引，但优化器会忽略该索引，直到
你决定让它可见。这样，您就可以在复制拓扑中推出新索引，或禁用您认为不需要或类似的索引。您可以快速启用或禁用索引，因
为这只需要更新表的元数据，所以变化是 "即时 "的。

例如，如果您认为不需要某个索引，那么在告诉 MySQL 删除索引之前，先将其隐藏起来，这样就可以监控数据库在没有索引的情
况下是如何运行的。如果发现某些查询（例如，在您监控期间未执行的月度报告查询）确实需要索引，您可以快速重新启用它。

使用 INVISIBLE 关键字可将索引标记为不可见，使用 VISIBLE 关键字可将不可见索引恢复为可见。例如，要在 world.city
表的 Name 列上创建一个不可见索引，并在以后使其可见，可以使用

#+begin_src sql
  alter table world.city add index(Name) invisible;
#+end_src

#+begin_src sql
  alter table world.city alter index Name visible;
#+end_src

如果禁用了某个索引，而查询使用了指向隐藏索引的索引提示，查询将返回错误：

#+begin_comment
  ERROR: 1176: Key 'Name' doesn't exist in table 'city'
#+end_comment

通过启用优化器开关 use_invisible_indexes（默认为关闭），可以覆盖索引的不可见性。如果由于索引不可见而遇到问题，
且无法立即重新启用，或者想在新索引普遍可用之前对其进行测试，这将非常有用。为连接临时启用不可见索引的示例如下

#+begin_src sql
  SET SESSION optimizer_switch = 'use_invisible_indexes=on';
#+end_src

即使启用了 use_invisible_indexes 优化开关，也不允许在索引提示中引用该索引。

MySQL 8 的另一项新功能是降序索引。

** 降序索引

在 MySQL 5.7 及更早版本中，当您添加 B 树索引时，它总是按升序排序。这非常适合查找精确匹配、按索引升序检索行等。
不过，虽然升序索引可以加快按降序查找行的查询速度，但效果并不理想。MySQL 8 增加了降序索引来帮助解决这些用例。

要利用降序索引，并不需要做什么特别的事情。例如，只需在索引中使用 DESC 关键字即可：

#+begin_src sql
  alter table world.city add index(Name DESC);
#+end_src

如果索引中有多个列，则这些列不必都按升序或降序排列。您可以根据查询的最佳效果，混合使用升序和降序列。

** 分区和索引

如果创建分区表，分区列必须是主键和所有唯一键的一部分。这样做的原因是 MySQL 没有全局索引的概念，因此必须确保唯一性
检查只需考虑单个分区。

在性能调整方面，分区可以有效地使用两个索引来解决查询问题，而无需使用索引合并。当用于分区的列在查询的条件中使用时，
MySQL 会剪切分区，因此只搜索条件可以匹配的分区。然后就可以使用索引来解决查询的其余部分。

考虑一个表 t_part，该表根据 Created 列（时间戳）进行分区，每个月一个分区。如果查询 2019 年 3 月所有 val 列值
小于 2 的记录，那么查询将首先剪切 Created 值上的分区，然后使用 val 上的索引。清单 14-12 显示了这样一个示例。

#+begin_src sql
  create table t_part(
     id int unsigned not null auto_increment,
     Created timestamp not null,
     val int unsigned not null,
     primary key (id, Created),
     index(val)
  )engine=InnoDB 
  partition by range(unix_timestamp(Created))
  (partition p201901 values less than (1548939600),
  partition p201902 values less than (1551358800),
  partition p201903 values less than (1554037200),
  partition p201904 values less than (1556632800),
  partition p201905 values less than (1559311200),
  partition p201906 values less than (1561903200),
  partition p201907 values less than (1564581600),
  partition p201908 values less than (1567260000),
  partition pmax values less than maxvalue);
#+end_src

#+begin_src sql
  insert into t_part(Created, val)
  with recursive counter(i) as (
   select 1 
   union select i+1
   from counter 
   where i<1000)
  select FROM_UNIXTIME(
   floor(rand()*(1567260000-1546261200))
   +1546261200) , floor(rand()*10) from counter;
#+end_src

#+begin_src sql
  explain select id, Created, val 
  from t_part tp 
  where Created between '2019-03-01 00:00:00' and '2019-03-31 23:59:59' and val<2
#+end_src

t_part 表使用创建列的 Unix 时间戳按范围分区。EXPLAIN 输出（第 20 章将详细介绍 EXPLAIN）显示，查询中将只包含
p201903 分区，并使用 val 索引作为索引。由于示例使用的是随机数据，因此 EXPLAIN 的确切输出可能会有所不同。

到目前为止，关于索引的所有讨论都是针对明确创建的索引。对于某些查询，MySQL 还可以自动生成索引。这是我们要讨论的最后
一项索引功能。

** 自动生成索引

对于包含连接到其他表或子查询的子查询的查询，由于子查询不能包含显式索引，因此连接可能会很昂贵。为了避免在这些由子查
询生成的临时表上进行全表扫描，MySQL 可以在连接条件上添加一个自动生成的索引。

以 sakila 示例数据库中的电影表为例。表中有一列名为 release_year，表示电影上映的年份。如果要查询在有数据的年份中
每年有多少部电影上映，可以使用下面的查询（是的，如果不使用子查询，这个查询可以写得更好，但这样写是为了演示自动生成
索引的功能）：

#+begin_src sql
  SELECT release_year, COUNT(*)
  FROM sakila.film
  INNER JOIN
  (SELECT DISTINCT release_year FROM sakila.film ) release_years USING (release_year)
  GROUP BY release_year;
#+end_src

MySQL 选择对电影表进行全表扫描，并在子查询中添加自动生成索引。当 MySQL 添加自动生成索引时，EXPLAIN 输出将包括
<auto_key0>（或用不同值替换的 0）作为可能的键和使用的键。

自动生成的索引可以大幅提高包含子查询的查询性能，而优化程序无法将这些子查询重写为普通连接。最重要的是，它是自动生成
的。

关于索引功能的讨论到此结束。在讨论如何使用索引之前，还需要了解 InnoDB 如何使用索引。

** InnoDB和索引

自 20 世纪 90 年代中期推出第一个版本以来，InnoDB 组织表的方式一直是使用聚类索引来组织数据。因此，人们常说
InnoDB 中的一切都是索引。从字面上看，数据的组织就是索引。默认情况下，InnoDB 使用主键来建立聚类索引。如果没有主
键，它会寻找不允许 NULL 值的唯一索引。在万不得已的情况下，InnoDB 会使用自动递增计数器为表添加一个隐藏列。

对于索引组织的表，InnoDB 中的所有内容都是索引。聚类索引本身是作为 B+ 树索引组织的，实际行数据位于叶子页中。这对
查询性能和索引有一些影响。接下来的章节将介绍InnoDB如何使用主键，以及这对次键意味着什么，提供一些建议，并探讨索
引组织表的最佳用例。

** 聚集索引

由于数据是根据聚类索引（主键或其替代物）组织的，因此主键的选择非常重要。如果在现有值之间插入一条带有主键值的新记录，
InnoDB 就必须重新组织数据，为新记录腾出空间。在最坏的情况下，InnoDB 将不得不把现有页面一分为二，因为页面的大小是
固定的。页面拆分会导致叶页面在底层存储上失去顺序，造成更多随机 I/O，进而导致查询性能下降。页面拆分将作为第25章
中DDL和批量数据加载的一部分进行讨论。

** 二级索引

二级索引的叶子页存储对行本身的引用。由于行是根据聚类索引存储在 B+ 树索引中的，因此所有二级索引都必须包含聚类索引的
值。如果您选择的列的值需要很多字节，例如具有长字符串且可能是多字节字符串的列，这将大大增加二级索引的大小。

这也意味着，在使用二级索引执行查找时，实际上要进行两次索引查找：首先是预期的二级键查找，然后从叶子页获取主键值，并
用于主键查找以获取实际数据。

对于非唯一二级索引，如果您有一个显式主键或一个 NOT NULL 唯一索引，用于主键的列就会被添加到索引中。MySQL 知道这
些额外的列，即使它们没有显式地成为索引的一部分，如果能改善查询计划，MySQL 就会使用它们。

** 建议

由于 InnoDB 使用主键的方式，以及将主键添加到二级索引的方式，因此最好使用单调递增的主键，使用的字节数越少越好。自
动递增整数符合这些特性，因此是很好的主键。

如果表没有任何合适的索引，用于聚类索引的隐藏列会使用类似于自动递增的计数器来生成新值。但是，由于该计数器对 MySQL
实例中带有隐藏主键的所有 InnoDB 表都是全局的，因此会成为一个争用点。在复制过程中，隐藏键也不能用于定位受事件影响
的行，而分组复制需要主键或 NOT NULL 唯一索引来进行冲突检测。因此，建议始终为所有表明确选择一个主键。

另一方面，UUID 并不是单调递增的，因此不是一个好的选择。MySQL 8 中的一个选项是使用 UUID_TO_BIN()函数，并将第二
个参数设置为 1，这将使 MySQL 交换第一组和第三组十六进制数字。第三组是 UUID 时间戳部分的高字段，因此将其提升到
UUID 的开头有助于确保 ID 不断增加，而且将其存储为二进制数据所需的存储空间不到十六进制值的一半。

** 最佳使用案例

索引组织的表对于使用该索引的查询特别有用。正如 "聚类索引 "这个名字所暗示的，聚类索引中具有相似值的记录会被存储在彼
此附近。由于 InnoDB 总是将整个页面读入内存，这也意味着主键值相似的两条记录很可能被一起读入。如果你在查询中或相隔
不久执行的查询中同时需要这两条记录，那么缓冲池中已经有了第二条记录。

现在，您应该对 MySQL 中的索引以及 InnoDB 如何使用索引（包括其数据组织）有了很好的背景知识。现在是将这些知识综合
起来讨论索引策略的时候了。

** 索引策略

说到索引，最大的问题是索引什么，其次是使用哪种索引和索引的哪些功能。我们不可能一步一步地创建终极指南来确保最佳索引；
为此，我们需要经验以及对模式、数据和查询的充分理解。不过，我们可以给出一些一般性指导原则，本节将对此进行讨论。

首先要考虑的是何时添加索引；是在最初创建表格时添加，还是稍后再添加。然后是主键的选择以及如何选择主键。最后是二级索
引，包括向索引中添加多少列，以及索引是否可以用作覆盖索引。

** 什么时候应该新增索引或删除索引

索引维护是一项永无止境的任务。它从创建表格时就开始了，并贯穿整个表的生命周期。不要对索引工作掉以轻心--如前所述，好
的索引和差的索引之间的差别可能是几个数量级。如果索引效果不佳，就无法通过投入更多硬件资源来摆脱困境。索引不仅会影响
原始查询性能，还会影响锁定（将在第 18 章中进一步讨论）、内存使用率和 CPU 使用率。

创建表格时，尤其要花时间选择一个好的主键。在表的生命周期内，主键通常不会发生变化，如果你决定更改主键，对于索引组织
的表来说，必然需要对表进行全面重建。二级索引在更大程度上可以随着时间的推移而调整。事实上，如果计划在表的初始数据量
中导入大量数据，最好等到数据加载完成后再添加二级索引。唯一索引可能是一个例外，因为数据验证需要唯一索引。

创建表格并填充初始数据后，需要监控表格的使用情况。在 sys 模式中有两个视图可用于查找表和进行全表扫描的语句：

+ schema_tables_with_full_table_scans 该视图显示所有未使用索引读取记录的表，并按该数字降序排列。如果某个表
  在未使用索引的情况下读取了大量记录，则可以查找使用该表的查询，看看索引是否能提供帮助。该视图基于
  table_io_waits_summary_by_index_usage 性能模式表，也可以直接使用，例如，如果要进行更高级的分析，如查找未
  使用索引读取的行的百分比。

+ statements_with_full_table_scans 该视图显示了完全不使用索引或不使用良好索引的语句的规范化版本。这些语句按
  完全不使用索引的执行次数排序，然后按不使用良好索引的次数排序--均以降序排列。该视图基于
  events_ statements_summary_by_digest 性能模式表。


第 19 章和第 20 章将详细介绍这些视图和底层性能模式表的使用。

如果发现查询可以从额外的索引中获益，那么就需要评估在执行查询时，额外获益的成本是否值得。

同时，还需要留意是否有不再使用的索引。performance schema和sys schema式对查找未使用或不常用的索引特别有用。
以下三个系统模式视图非常有用

- schema_index_statistics 该视图统计了使用给定索引读取、插入、更新和删除行的频率。与
  schema_tables_with_full_table_scan 视图一样，schema_index_statistics 也是基于
  table_io_waits_ summary_by_index_usage 性能模式表。

- schema_unused_indexes 该视图将返回自上次重置数据以来（不长于上次重启时间）尚未使用的索引名称。该视图也基于
  table_io_waits_summary_by_index_usage 性能模式表。

- schema_redundant_indexes 如果有两个索引覆盖相同的列，那么 InnoDB 为保持索引最新而付出的努力就会加倍，优化
  器的负担也会加重，但却不会有任何收获。顾名思义，schema_redundant_indexes视图可以用来查找冗余索引。该视图基
  于 STATISTICS 信息模式表。

使用前两个视图时，必须记住数据来自performance schema中的内存表。如果您有一些查询只是偶尔执行，那么统计数据可
能无法反映您的总体索引需求。在这种情况下，隐形索引功能就会派上用场，因为它可以让你禁用索引，同时保留索引，直到你确
定可以安全地放弃它。如果发现一些很少执行的查询需要索引，你可以很容易地再次启用索引。

如前所述，首先要考虑的是选择什么作为主键。应该包括哪些列？这是接下来要讨论的问题。

** 主键的选择

在使用索引组织的表时，主索引的选择非常重要。主键会影响随机 I/O 和顺序 I/O 的比例、二级索引的大小以及需要读入缓冲
池的页数。InnoDB 表的主键始终是 B+ 树索引。

与聚类索引相关的最佳主键应尽可能小（以字节为单位），保持单调递增，并在短时间内对频繁查询的记录进行分组。在实践中，
可能无法满足所有这些要求，在这种情况下，你需要做出最好的妥协。对于许多工作负载来说，自动递增的无符号整数（取决于表
的预期行数，可以是 int 也可以是 bigint）是一个不错的选择；不过，也可能有一些特殊的考虑因素，比如对跨多个 MySQL
实例的唯一性的要求。主键最重要的特点是，它应尽可能具有顺序性和不可更改性。如果更改了某一行的主键值，则需要将整行移
动到聚类索引中的新位置。

#+begin_comment
  自动递增的无符号整数通常是主键的最佳选择。它可以单调递增，不需要太多存储空间，还能在聚类索引中将最近的记录分组。
#+end_comment

你可能会认为，隐藏主键和其他列一样，是聚类索引的最佳选择。毕竟，它是一个自动递增的整数。然而，隐藏主键有两个主要缺
点：它只能识别本地 MySQL 实例中的行，而且计数器对（实例中的）所有 InnoDB 表都是全局的，没有用户定义的主键。隐藏
键只在本地有用，这意味着在复制过程中，隐藏值不能用来识别要在副本中更新的记录。计数器是全局性的，这意味着在插入数据
时，它可能会成为一个争夺点，并导致性能下降。

总之，你应该明确定义你想要的主键。对于二级索引，有更多的选择，我们接下来会看到。

** 新增二级索引

二级索引指的是主键之外的所有索引。它们可以是唯一的，也可以是非唯一的，你可以在所有支持的索引类型和功能中进行选择。
如何选择添加哪些索引？本节将帮助你更轻松地做出决定。

注意不要在表中添加过多索引。索引会产生开销，因此如果添加的索引最终没有被使用，查询和系统的整体性能就会变差。这并不
意味着在创建表格时不应该添加任何二级索引。只是你需要花点心思在这上面。

在执行查询时，可以通过多种方式使用二级索引。其中一些方法如下：

+ 减少检查的记录： 当使用 WHERE 子句或连接条件时，可以在不扫描整个表的情况下找到所需的记录。
+ 排序数据： B 树索引可用于按照查询需要的顺序读取行，从而让 MySQL 绕过排序步骤。
+ 验证数据： 这就是唯一索引中唯一性的用途。
+ 避免读取整行： 覆盖索引可以在不读取整行的情况下返回所有需要的数据。
+ 查找 MIN() 和 MAX() 值： 对于 GROUP BY 查询，只需检查索引中的第一条记录和最后一条记录，即可找到索引列的最小
  值和最大值。

主键显然也可以用于所有这些目的。从查询的角度看，主键和次键没有区别。

在决定是否添加索引时，您需要问问自己需要索引的目的是什么，以及索引是否能够实现这些目的。一旦确认了这一点，就可以考
虑多列索引应该按照什么顺序添加列，以及是否应该添加额外的列。接下来的两个小节将对此进行更详细的讨论。

** 多列索引

只要不超过索引的最大宽度，就可以在索引中添加多达 16 个列或功能部分。这既适用于主键，也适用于二级索引。InnoDB 对
每个索引的限制是 3072 字节。如果包含使用可变宽度字符集的字符串，那么计算索引宽度的是可能的最大宽度。

在索引中添加多个列的一个好处是，可以将索引用于多个条件。这是提高查询性能的有效方法。举例来说，如果要查询某个国家的
城市，并要求该城市的最低人口数： 

#+begin_src sql
  select ID, Name, District, Population
  from world.city
  where CountryCode='AUS'
  and Population>1000000;
#+end_src

您可以在 CountryCode 列上使用索引来查找国家代码设置为 AUS 的城市，也可以在 Population 列上使用索引来查找人口
超过 100 万的城市。更妙的是，您可以将其合并为一个包含两列的索引。

如何做到这一点很重要。国家代码使用的是等量引用，而人口则是范围搜索。索引中的列一旦用于范围搜索或排序，除了作为覆盖
索引的一部分外，就不能再使用索引中的其他列。在本例中，需要在 "人口 "列之前添加 "国家代码 "列，以便将索引用于两个
条件：

#+begin_src sql
  alter table world.city
  add index (CountryCode, Population);
#+end_src

在这个例子中，索引甚至可以用来对结果进行排序。

如果需要添加多个列，且所有列都用于相等条件，那么需要考虑两点：哪些列最常用，以及列过滤数据的效果如何。当索引中有多
个列时，MySQL 将只使用索引的左前缀。例如，如果您有一个索引（col_a、col_b、col_c），那么只有同时对 col_a 进行
过滤（而且必须是相等条件），才能使用该索引对 col_b 进行过滤。因此需要谨慎选择顺序。在某些情况下，可能需要为同一列
添加多个索引，而索引之间的列顺序是不同的。

如果无法根据使用情况决定包含列的顺序，则先添加选择性最强的列。下一章将讨论索引的选择性，但简而言之，列的独特值越多，
选择性就越强。通过先添加选择性最强的列，可以更快地缩小索引部分包含的行数。

您可能还想包含不用于筛选的列。为什么要这样做呢？答案是这有助于形成覆盖索引。

** 覆盖索引

覆盖索引是一个表上的索引，其中给定查询的索引包括该表所需的所有列。这意味着，当 InnoDB 到达索引的叶子页时，它已经
掌握了所需的全部信息，而不需要读取整条记录。根据表的具体情况，这可能会大大提高查询性能，尤其是如果你能用它来排除行
中的大部分内容，比如大文本或 blob 列。

还可以使用覆盖索引来模拟二级聚类索引。请记住，聚类索引只是一个 B+ 树索引，整个行都包含在叶子页中。覆盖索引在叶子
页中包含行的一个完整子集，因此可以模拟该子集列的聚类索引。与聚类索引一样，任何 B 树索引都会将相似的值组合在一起，
因此可以用来减少读入缓冲池的页数，并有助于在执行索引扫描时进行顺序 I/O。

不过，与聚类索引相比，覆盖索引有一些限制。覆盖索引只能在读取时模拟聚类索引。如果你需要写入数据，那么更改始终必须访
问聚类索引。另外，由于 InnoDB 的多版本并发控制 (MVCC)，即使使用覆盖索引，也必须检查聚簇索引，以验证是否存在该行
的另一个版本。

添加索引时，值得考虑的是索引的查询需要哪些列。即使索引不用于对这些列进行筛选或排序，也值得添加选择部分中使用的任何
额外列。您需要在覆盖索引的好处和索引增加的大小之间取得平衡。因此，如果只是漏掉一两个小列，这种策略就很有用。覆盖索
引带来的查询效益越大，您可以接受添加到索引中的额外数据也就越多。

** 总结

本章是一次索引世界之旅。一个好的索引策略意味着数据库是停滞不前还是运转良好。索引有助于减少查询中检查的记录数量，此
外，覆盖索引可以避免读取整条记录。另一方面，索引在存储和持续维护方面也会产生开销。因此，有必要平衡对索引的需求和建
立索引的成本。

MySQL 支持几种不同的索引类型。最重要的是 B 树索引，这也是 InnoDB 使用聚类索引在其索引组织表中组织行时使用的索
引。其他索引类型包括全文索引、空间（R 树）索引、多值索引和哈希索引。后一种类型在 InnoDB 中比较特殊，因为它只支
持自适应哈希索引功能，该功能会自动决定添加哪些哈希索引。

我们已经讨论过一系列索引功能。功能索引可用于对表达式中使用列的结果进行索引。前缀索引可用于减少文本和二进制数据类型
索引的大小。在推出新索引或软删除现有索引时，可以使用隐形索引。降序索引可提高按降序遍历索引值的效率。索引还与分区相
关联，您可以使用分区有效地实现支持在查询中对单个表使用两个索引。最后，MySQL 能够自动生成与子查询相关的索引。

本章的最后一部分首先介绍了 InnoDB 的特性以及使用索引组织表的注意事项。对于与主键相关的查询，这些表是最佳选择，但
对于以随机主键顺序插入的数据和通过二级索引查询数据，这些表的效果就没那么好了。

本章的最后一部分首先介绍了 InnoDB 的特性以及使用索引组织表的注意事项。对于与主键相关的查询，这些表是最佳选择，但
对于以随机主键顺序插入的数据和通过二级索引查询数据，这些表的效果就没那么好了。

关于什么是索引以及何时使用索引的讨论到此结束。在下一章讨论索引统计时，我们将看到更多关于索引的内容。




* 索引统计

在上一章中，我们学习了索引。其中提到，优化器会评估每个索引，以决定是否使用该索引。它是如何做到这一点的呢？这主要是本
章的主题，包括索引统计、如何查看索引统计信息以及如何维护统计。

** 什么是索引统计？

当 MySQL 决定是否使用索引时，归根结底要看 MySQL 认为索引对查询有多有效。请记住，当你使用二级索引时，实际上会有一
个额外的主键查询来获取数据。二级索引的排序方式也与行的排序方式不同，因此使用索引一般意味着随机 I/O（使用覆盖索引可
以帮助解决这个问题）。另一方面，表扫描在很大程度上是顺序 I/O。因此，逐行进行表扫描要比使用二级索引查找同一行便宜。

这意味着，要使索引有效，必须过滤掉表的大部分内容。具体要过滤掉多少，取决于硬件的性能特性、缓冲池中表的容量、表的定
义等。在老式旋转磁盘时代，经验法则是如果需要的行超过 30%，则首选表扫描。内存中的行越多，磁盘的随机 I/O 性能越好，
这个阈值就越高。

#+begin_comment
  覆盖索引可以减少从跳转到实际行数据所需的随机 I/O 量，从而改变这种情况。
#+end_comment

这就是索引统计的作用所在。优化器（MySQL 中决定使用哪种查询计划的部分）需要一些简单的方法来确定给定查询计划的索引
好坏。优化器显然知道索引包含哪些列，但它还需要知道索引过滤行的效果如何。这些信息正是索引统计信息所提供的。因此，索
引统计信息是索引选择性的衡量标准。主要有两种统计数据：唯一值的数量和某个范围内的值的数量。

在讨论索引统计时，人们最常想到的是唯一值的数量。这就是索引的卡入度。卡片性越高，唯一值越多。对于主键和其他不允许
NULL 值的唯一索引来说，由于所有值都必须是唯一的，因此卡片性就是表中的行数。

优化程序会根据逐个查询请求给定范围内的行数。这对范围条件（如 WHERE val > 5）、IN()条件或一系列 OR 条件都很有
用。为单个查询临时收集这些信息的一个例外是直方图，MySQL 8 支持直方图。下一章将讨论直方图。

简而言之，索引统计是关于索引中数据分布的近似信息。在 MySQL 中，负责提供索引统计信息的是存储引擎。因此，InnoDB
如何处理索引统计是值得深入研究的。

** InnoDB和索引统计

正是存储引擎向服务器层和优化器提供了索引统计数据。因此，了解 InnoDB 如何确定其统计数据非常重要。InnoDB 支持两种
存储统计数据的方式：持久性和瞬时性。无论哪种方式，统计信息的确定方法都是一样的。本节将首先讨论如何收集统计数据，然
后介绍持久和瞬时统计数据的具体细节。

** 统计是怎样收集的

InnoDB 通过分析索引的随机叶页来计算索引统计数据。例如，可能会随机抽取 20 个索引页（这也被称为 20 个索引潜入），
并检查这些页包含哪些索引值。然后，InnoDB 会根据索引的总大小进行缩放。

这意味着 InnoDB 索引统计数据并不精确。当你看到某个查询条件意味着将读取 100 条记录时，这只是根据分析样本得出的估
计值。这甚至包括主键和其他唯一索引，以及在 information_schema.TABLES视图。表中的估计行数与主键的估计卡长度相
同。

另一个考虑因素是如何处理 NULL 值，因为 NULL 具有不等于 NULL 的属性。因此，在收集统计数据时，是将所有 NULL 值归
入一个数据桶，还是将它们分开处理？最佳解决方案取决于您的查询。将所有 NULL 值视为不同的值会增加索引的卡入度，尤其是
在索引列有很多 NULL 行的情况下。这对查找非 NULL 值的查询很有帮助。另一方面，如果将所有 NULL 都视为相同值，则会降
低索引的核心数量，这对于包含 NULL 的查询来说是有意义的。你可以使用 innodb_stats_method 选项来选择 InnoDB 处理
NULL 值的方式。该选项有三种取值：

+ nulls_equal 在这种情况下，所有 NULL 值都被视为相同。这是默认值。如果不确定选择哪个值，请选择 nulls_equal。
+ nulls_unequal 在这种情况下，NULL 值被视为不同的值。
+ nulls_ignored 在这种情况下，收集统计数据时将忽略 NULL 值。

为什么使用估算值而不是精确统计值（即全索引扫描）？原因在于性能。对于大型索引，执行完整的索引扫描需要很长时间。一般
还包括磁盘 I/O，这使得性能问题更加严重。为了避免计算索引统计量对查询性能产生不利影响，我们选择将扫描限制在相对较少
的页数上。

** 样本页

使用近似统计量的缺点是，它们并不总是能很好地代表值的实际分布。出现这种情况时，优化器可能会选择错误的索引或错误的连
接顺序，导致查询速度慢于所需。不过，也可以调整随机索引下潜的次数。如何调整取决于使用的是持久统计还是瞬时统计：

+ 持久性统计使用 innodb_stats_persistent_sample_ pages 选项作为默认的采样页数。表选项 STATS_SAMPLE_PAGES
  可以用来指定特定表的页数。

+ 暂态统计使用 innodb_ stats_transient_sample_pages 选项为所有表指定的页数。

关于持久统计和瞬时统计的两个小节详细介绍了处理索引统计的两种方法。

将样本页数设置为给定值是什么意思？这取决于索引中的列数。如果只有一列，该值的字面意思就是采样该数量的叶页。但是，对
于多列索引，页数是按列计算的。例如，如果将样本页数设置为 20，而索引中有四列，则总共采样 4*20=80 页。

#+begin_comment
  实际上，索引统计采样比本章描述的更为复杂。例如，并不总是需要一直向下到叶页。如果两个相邻的非叶子节点具有相同的
  值，那么可以得出结论：最左边（按照排序）的所有叶子页都具有相同的值。如果你有兴趣了解更多，源代码中
  storage/innobase/ dict/dict0stats.cc 文件顶部的注释是一个很好的起点：
  https://github.com/mysql/mysql-server/blob/8.0/ storage/innobase/dict/dict0stats.cc。
#+end_comment

必须检查多少页才能得到准确的估计？这取决于表格。如果数据是均匀的，即每个索引值的行数大致相同，那么只需要检查相对较
少的页数，默认页数通常就足够了。另一方面，如果数据分布很不规则，则可能需要增加采样页数。队列中任务的状态就是非常不
规则的数据的一个例子。随着时间的推移，大多数任务都会处于完成状态。在最糟糕的情况下，你可能会遇到所有随机潜水都看到
相同状态的情况，这使得 InnoDB 得出结论：只有一个值，索引作为过滤器毫无价值。

#+begin_comment
  对于仅有几行数据的过滤值，下一章将讨论的直方图对于改进查询计划非常有用。
#+end_comment

表格的大小也是一个需要考虑的因素。一般来说，表越大，必须检查的页数就越多，才能获得良好的估算结果。原因是表越大，整
个叶页就越有可能指向具有相同索引值的行。这就降低了每个取样页的值，因此为了弥补这一缺陷，有必要对更多页面进行取样。

一种特殊情况是 InnoDB 被配置为索引下潜次数多于叶子页的数量。在这种情况下，InnoDB 会检查所有叶子页，并在此时停止。
这将提供尽可能准确的统计数据。如果在分析过程中没有活动事务，那么该时间点的统计数据将是准确的。这包括表中的页数。您
将在本章稍后部分学习如何查找使用持久性统计的索引和表中的页数。

实际上，不可能使用精确的值。InnoDB 支持多版本，允许事务的高并发性，即使这些事务涉及写入。由于每个事务都有自己的数
据视图，精确的统计数据意味着每个事务都有自己的索引统计数据。这是不可行的，那么InnoDB是如何处理的呢？这是下一个
要考虑的问题。

** 事务隔离级别

与此相关的一个问题是，收集统计数据时使用的是哪种事务隔离级别。InnoDB 支持四种隔离级别：已读未提交、已读已提交、可
重复读（默认）和可序列化。在收集索引统计数据时，我们选择使用未提交读取。这是有道理的，因为可以很好地假定大多数事务
最终都会提交，或者如果提交失败会重试。这些统计信息将用于未来的查询，因此没有必要在收集统计信息时增加维护读视图的开
销。

不过，这对于对表进行较大更改的事务确实有影响。一个极端（但并非不可能）的例子是，考虑一个缓存表，其中的数据由一个包
含两个步骤的事务刷新：

1. 删除表中的所有现有数据。
2. 用更新的数据重建表格。

默认情况下，当表的 "大部分 "内容发生变化时，会更新索引统计信息。(本章后面的 "持久索引统计 "和 "瞬时索引统计 "部
分将介绍什么是 "大部分"）。这意味着步骤 1 完成后，InnoDB 将重新计算统计数据。这很简单--表是空的，所以没有统计数
据。如果查询就在此时执行，优化器会认为表是空的。不过，除非查询是在 "读取未提交事务 "隔离级别下执行的，否则查询仍会
读取所有旧行，而且查询计划很可能会导致查询执行效率低下。   

对于像刚才讨论的问题，你需要持久统计数据，因为有更好的配置选项来处理特殊情况。在讨论持久统计数据的细节之前，值得学
习的是如何在持久统计数据和瞬时统计数据之间做出选择。

** 配置统计类型

如前所述，InnoDB 有两种方式来存储索引统计信息。它可以使用持久存储，也可以使用暂存存储。你可以使用
innodb_stats_persistent 选项为表设置默认方法。设置为 1 或 ON（默认值）时，将使用持久性统计；设置为 0 或
OFF 时，将改为瞬时统计。还可以使用 STATS_ PERSISTENT 表选项为每个表配置统计方法。例如，要为 world.city 表启
用持久统计，可以使用 ALTER TABLE 这样的命令

#+begin_src sql
  alter table world.city STATS_PREPARED=1;
#+end_src

使用 CREATE TABLE 语句创建新表时，也可以设置 STATS_PERSISTENT 选项。对于 STATS_PERSISTENT，只能使用 0 和
1 作为值。

持久索引统计自推出以来一直是默认设置，也是推荐选择，除非遇到测试表明瞬态统计可以解决的问题。持久统计与瞬态统计之间
存在一些差异，必须加以了解。接下来将讨论这些差异。

** 持久性索引统计

持久索引统计是在 MySQL 5.6 中引入的，目的是使查询计划比旧的瞬时索引统计更稳定。顾名思义，启用持久索引统计后，统
计信息将被保存，因此在重启 MySQL 时不会丢失。不过，除了持久性之外，还有更多不同之处，我们将一一道来。

除了稳定的查询计划外，持久统计数据还允许对采样页数进行详细配置，并具有良好的监控功能，甚至可以直接查询保存统计数据
的表。由于监控与瞬态统计有很大的重叠，因此将在本章稍后部分讨论，本节将重点讨论持久统计的配置和存储统计的表。

** 配置

可以对持久统计数据进行配置，以便在收集统计数据的成本和统计数据的准确性之间取得良好的平衡。与瞬时统计不同的是，可以
在全局级别和每个表上配置行为。在未设置表特定选项时，全局配置将作为默认设置。

有三个全局选项专门针对持久性统计。它们是

+ innodb_stats_persistent_sample_pages： 要采样的页面数。页数越多，统计数据越准确，但成本也越高。如果该值大
  于索引的叶子页数，则对整个索引进行采样。默认值为 20。
+ innodb_stats_auto_recalc： 当表中超过 10%的行被更改时，是否自动更新统计信息。默认为启用 (ON)。
+ innodb_stats_include_delete_marked： 是否在统计中包含已标记为删除但尚未提交的记录。稍后将详细讨论这个选
  项。默认为禁用（OFF）。

innodb_stats_persistent_sample_pages 和 innodb_stats_auto_recalc 选项也可以按表设置。这样就可以根据特
定表的大小、数据分布和工作量来微调需求。虽然不建议进行微调，但可以用来处理前面讨论过的缓存表等情况，以及一般默认值
无法覆盖的其他表。

我们的建议是，尽量为 innodb_stats_ persistent_sample_pages 找到一个折中方案，既能提供足够好的统计数据，让优
化器确定最佳查询计划，又能避免为计算统计数据而进行过多的扫描。如果你发现由于索引统计数据不准确导致优化器选择了低效
计划，从而导致查询性能下降，那么你就需要增加采样页面的数量。另一方面，如果 ANALYZE TABLE 耗时过长，可以考虑减少
采样页数。然后，可以使用即将介绍的特定表选项，根据需要减少或增加特定表的采样页数。

对于大多数表，建议启用 innodb_stats_auto_recalc。这将有助于确保统计数据不会因为大量变更而过时。自动校验在后台
进行，因此不会延迟触发更新的应用程序的响应。当表中超过 10% 的内容发生变化时，表将排队等待索引统计更新。为避免不断
重新计算小表的统计数据，还要求每次索引统计数据更新之间至少间隔 10 秒。

当然，也有不希望自动重新计算统计数据的例外情况，例如，如果您有一个缓存表来加快报告查询的执行速度，而缓存表中的数据
会不时完全重建，但其他方面不会发生变化。在这种情况下，禁用统计数据的自动重新计算，并在重建完成后显式地重新计算统计
数据，可能会有好处。另一种方法是在统计中包含删除标记的行。

请记住，索引统计数据是使用读取未提交事务隔离级别计算的。虽然这在大多数情况下都能提供最佳统计数据，但也有例外。当事
务暂时完全改变了数据分布时，可能会导致不正确的统计数据。完全重建表是最极端的情况，也是最常见的问题所在。
innodb_stats_ include_delete_marked选项就是为这种情况而引入的。InnoDB 不会将未提交的已删除记录视为已删除，
而是仍将其纳入统计。该选项仅作为全局选项存在，因此即使只有一个表存在这个问题，它也会影响所有表。如前所述，另一种方
法是禁用受影响表的统计自动重新计算，然后自行处理。

#+begin_comment
  如果有事务会对表进行较大的更改，比如删除所有行然后重建表，那么可以考虑禁用表的索引统计自动重新计算功能，或者启用
  innodb_stats_include_delete_marked。
#+end_comment

到目前为止，只提到了全局选项。如何更改表的索引统计设置？由于可以使用 STATS_PERSISTENT 表选项来覆盖表的
innodb_stats_persistent 全局值，所以还有一些选项可以控制表的持久化统计行为。表选项包括

+ stats_auto_recalc： 重写表是否启用了自动重新计算索引统计量的功能。
+ stats_sample_pages： 重写表格的采样页数。

可以在使用 CREATE TABLE 创建表格时设置这些选项，也可以在之后使用 ALTER TABLE 设置这些选项，如清单 15-1 所
示。

#+begin_src sql
  create schema if not exists chapter_15;
  use chapter_15
  create table city(
    City_ID int unsigned not null auto_increment,
    City_Name varchar(40) not null,
    State_ID int unsigned not null,
    primary key(City_ID),
    index(City_Name, State_ID, City_ID)
  )STATS_AUTO_RECALC=0,
  STATS_SAMPLE_PAGES=10;
#+end_src

#+begin_src sql
  alter table city STATS_AUTO_RECALC=1,
                   STATS_SAMPLE_PAGES=20;
#+end_src

首先，创建表格城市，禁用自动校正功能，并设置 10 个样本页。然后更改设置，启用自动重复计算，并将样本页数增加到 20
页。请注意 ALTER TABLE 返回的受影响行数为 0。更改持久性统计选项只会更改表的元数据，因此会立即发生，不会影响数据。
这意味着你可以根据需要更改设置，而不必担心执行昂贵的操作。例如，您可能希望在批量操作中禁用自动重新计算。

有了调整指数统计的机会，对收集到的数据进行分析就显得尤为重要。在 "监控 "部分讨论瞬时统计数据后，将讨论一些一般方法。
不过，持久统计数据之所以持久，是因为它们存储在表中，这些表也提供了有价值的信息。

** 索引统计表

InnoDB 在 mysql 模式中使用两个表来存储与持久统计数据相关的数据。这些表不仅有助于研究统计数据和采样数据，还有助于
了解索引的总体情况。

最常用的表是 innodb_index_stats 表。该表为每个 B 树索引提供了几行信息，包括索引各部分的唯一值数量
（cardinality）、索引中的叶子页数量以及索引的总大小。表 15-1 总结了表中的列。

| 列名              | 数据类型          | 描述                                       |
|------------------+-----------------+-------------------------------------------|
| database_name    | varchar(64)     | 模式中带有索引的表的位置。                     |
| table_name       | varchar(199)    | 带索引的表名                                |
| index_name       | varchar(64)     | 索引名                                     |
| last_update      | timestamp       | 上一次索引统计更新                           |
| stat_name        | varchar(64)     | 统计量的名称。另请参阅本表后的内容。            |
| stat_value       | bigint unsigned | 统计值                                     |
| sample_size      | bigint unsigned | 采样多个页                                  |
| stat_description | varchar(1024)   | 统计量的描述。对于卡入度，它是计算卡入度时包含的列 |

主键由列 database_name、table_name、index_name 和 stat_name 组成。数据库、表和索引名称定义了统计数据所针
对的索引。last_update 列用于查看统计信息上次更新的时间。stat_name 和 stat_value 为实际统计数据。sample_size
是为确定统计数据而检查的页数。这将是索引中的页数和为表设置的样本页数中较小的一个。最后，stat_description 列提供
了有关统计量的更多信息。对于卡片式统计，说明将显示索引中包含哪些列，每列将有一行（稍后将提供示例）。

如前所述，innodb_index_stats 表中包含多种统计信息。名称可以是以下值之一：

+ n_diff_pfxNN： 索引中前 NN 列的卡片数。NN 以 1 为单位，因此对于有两列的索引来说，n_diff_pfx01 和
  n_diff_pfx02 是存在的。对于具有这些统计量的行，stat_ description 包括统计量所包含的列。
+ n_leaf_pages： 索引中叶页的总数。您可以将其与 n_diff_pfxNN 统计量的样本大小进行比较，以确定已采样索引的部分。
+ size： 索引的总页数。这包括非叶页。

看一个示例可以更好地理解这些数据的含义。world.city 表有两个索引：ID 列上的主键和 CountryCode 列上的
CountryCode 索引。清单 15-2 显示了这两个索引的统计信息。请注意，如果执行相同的查询，统计值可能会有所不同，如果
仍有第 14 章中添加的额外索引，则会有更多记录。

#+begin_src sql
  select index_name, stat_name,
         stat_value, sample_size,
         stat_description
   from mysql.innodb_index_stats
   where database_name='world'
         and table_name='city'\G;
#+end_src

第 1-4 行是 CountryCode 索引，而第 5-7 行是主键。首先要注意的是，CountryCode 索引同时存在 n_diff_pfx01
和 n_diff_pfx02 统计量。为什么索引只包含一列？请记住，InnoDB 使用的是聚类索引，而非唯一索引总是会附加主键，因
为无论如何都需要它来定位实际行。这就是 n_diff_pfx01 代表 CountryCode 列，n_diff_pfx02 代表 CountryCode
列和 ID 列的组合。

CountryCode 索引共有 8 页，其中 7 页是叶节点。这意味着索引有两级，叶节点为第 0 级，根节点为第 1 级。我们建议你
回顾上一章关于 B 树索引的讨论，并在查看表中某些索引的大小统计时复习一下。

主键比较简单，因为它只有一列。这里有 24 个叶页，因此只对索引的一个子集进行了采样（记住，对于主键来说，索引就是表）。
(记住，对于主键来说，索引就是表。）这样做的后果是统计数据并不精确。主键的 n_diff_pfx01 预测值为 4188 个唯一值。
由于它是主键，这也是对总行数的估计。但是，如果查看 CountryCode 的统计信息，就会发现 CountryCode 和 ID 值有
4079 种不同的组合。由于 CountryCode 索引只有 7 个叶页，所有页都已检查过，因此行数估算是准确的。

另一个与持久化统计相关的表是 innodb_table_stats 表。它与 innodb_index_stats类似，不同之处在于它包含的是整
个表的汇总统计。表 15-2 概括了 innodb_table_stats 的列。


#+NAME: innodb_table_stats
| 列名                      | 数据类型          | 描述              |
|--------------------------+-----------------+------------------|
| database_name            | varchar(64)     | 表所在的模式名      |
| table_name               | varchar(199)    | 表名              |
| last_update              | timestamp       | 上次表统计更新的时间 |
| n_rows                   | bigint unsigned | 表中行的估算数据    |
| clustered_index_size     | bigint unsigned | 聚簇索引的页数      |
| sum_of_other_index_sizes | bigint unsigned | 二级索引的总计页数        |

主键由列 database_name 和 table_name 组成。需要注意的一点是，表统计量与索引统计量一样都是近似值。表中的行数只
是主键的估计卡入度。同样，聚类索引的大小与 innodb_index_stats 表中主键的大小相同。二级索引页数是每个二级索引大
小的总和。清单 15-3 以 world.city 表为例，展示了 innodb_table_stats 表的内容，使用的索引统计量与前面的示例
相同。

#+begin_src sql
  select *
     from mysql.innodb_table_stats
     where database_name='world'
       and table_name='city'\G
#+end_src

#+begin_comment
  innodb_index_stats和innodb_table_stats是常规表。在备份中包含这些表是很有用的，这样如果查询计划突然发生
  变化，就可以回过头来比较统计数据。

  还可以为具有 UPDATE 权限的用户更新表。这似乎是一个非常有用的属性，但要小心。如果不知道正确的统计信息，查询计划
  将非常糟糕。几乎不应该手动修改索引统计信息。如果进行了修改，只有在刷新表后才会生效。
#+end_comment

如果你觉得innodb_index_stats和innodb_table_stats中的信息与SHOW INDEX语句、TABLES和STATISTICS
信息模式表中的信息听起来很相似，那你就对了。两者有一些重叠。由于这些数据源也适用于瞬态统计，因此对它们的讨论将推迟到
介绍完瞬态索引统计之后。

** 暂态指数统计

瞬态索引统计是 InnoDB 最初实现的处理索引统计的方法。顾名思义，这种统计不是持久性的，也就是说，当 MySQL 重新启动
时，它们不会持久存在。相反，统计信息是在表首次打开时（还有其他时间）计算的，并且只保存在内存中。由于统计数据不持
久，因此稳定性较差，查询计划更容易发生变化。

有两个配置选项可以影响瞬态统计的行为。它们是

+ innodb_stats_transient_sample_pages： 更新索引统计时采样的页数。默认值为 8。
+ innodb_stats_on_metadata： 查询表的元数据时是否重新计算统计数据。默认值为 OFF，自 MySQL 5.6 起一直如此。

innodb_stats_transient_sample_pages选项等同于innodb_stats_ persistent_sample_pages，但它适用于使用
瞬态统计的表。使用瞬态统计的表不仅会在首次打开时重新计算统计量，而且还会在仅有 6.25% (1/16) 行发生变化时重新计算
统计量，并要求至少有 16 次更新。此外，在自动重新计算统计数据时，瞬态统计数据不使用后台线程，因此更新更有可能影响性
能。因此，innodb_stats_ transient_sample_pages 的默认值只有 8 页。

如果想更频繁地更新瞬时索引统计信息，可以启用 innodb_stats_on_metadata 选项。启用该选项后，查询信息模式中的
TABLES 表和 STATISTICS 表，或使用与之相当的 SHOW 语句，都会触发索引统计信息的更新。在实际操作中，很少会出现这
种情况，因此关闭该选项是安全的。

暂态统计没有专门的表。不过，MySQL 中的所有表都有可用的表和语句。

** 监控

索引统计信息对于优化器帮助确定执行查询的最佳方式非常重要。因此，了解如何检查表的索引统计也很重要。前面已经讨论过，
有 mysql.innodb_index_stats 表和 mysql.innodb_table_stats 表可用于持久化统计。不过，也有一些通用方法，本
文将讨论这些方法。

#+begin_comment
  请记住，information_schema_stats_expiry 变量会影响数据字典刷新索引统计相关数据视图的频率。
#+end_comment

** 信息模式 STATISTICS 视图

获取索引统计详细信息的主要表格是信息模式中的 STATISTICS 视图。该视图不仅包含索引统计信息本身，还包含索引的元信
息。事实上，你可以根据 STATISTICS 视图中的数据重新创建索引定义。这就是上一章中用来查找表中索引名称的视图。

表 15-3 包含视图中各列的摘要。您通常只需要其中的一部分列，但在需要时访问所有信息还是很方便的。CARDINALITY 列是
唯一受 information_schema_stats_expiry 变量影响的列。

#+NAME:STATISTICS
| 列名           | 数据类型       | 描述                                                             |
|---------------+--------------+-----------------------------------------------------------------|
| TABLE_CATALOG | varchar(64)  | 表格所属的目录。                                                   |
| TABLE_SCHEMA  | varchar(64)  | 表格所在的模式。                                                   |
| TABLE_NAME    | varchar(64)  | 索引所在的表。                                                     |
| NON_UNIQUE    | int          | 索引是否唯一（0）或不唯一（1）。                                     |
| INDEX_SCHEMA  | varchar(64)  | 与 TABLE_SCHEMA 相同（因为索引总是与表同处）。                        |
| INDEX_NAME    | varchar(64)  | 索引名                                                           |
| SEQ_IN_INDEX  | int unsigned | 列在索引中的位置。对于单列索引，该值始终为 1。                          |
| COLUMN_NAME   | varchar(64)  | 列名                                                             |
| COLLATION     | varchar(1)   | 索引的排序方式。值可以是 NULL（不排序）、a（升序）或 d（降序）。          |
| CARDINALITY   | bigint       | 该行中包含列的索引部分的唯一值的估计数量。                             |
| SUB_PART      | bigint       | 对于前缀索引，它是被索引的字符数或字节数。如果整个列都被索引，则值为 NULL。 |
| PACKED        | binary(0)    | 对于 InnodB 表，该值始终为空。                                      |
| NULLABLE      | varchar(3)   | 是否允许 NULL 值，该列要么为空字符串，要么为 "是"。                    |
| INDEX_TYPE    | varchar(11)  | 索引类型，比如BTree索引                                            |
| COMMENT       | varchar(8)   | 关于索引的额外信息。                                                |
| IS_VISIBLE    | varchar(3)   | 索引是可见（是）还是不可见（否）。                                    |
| EXPRESSION    | longtext     | 对于功能索引，此列包含用于生成索引值的表达式。对于非功能索引，该值始终为空。                                                                |

STATISTICS 视图不仅对索引统计有用，而且对索引本身也很有用，它包含了所有索引的信息，与索引类型无关。例如，你可以用
它来查找不可见索引和用于功能索引的表达式。关于索引统计，最有趣的列是 CARDINALITY，它是索引中估计存在的唯一值的数
量。

查询 STATISTICS 视图时，建议按照 TABLE_SCHEMA、TABLE_NAME、INDEX_NAME 和 SEQ_IN_INDEX 列对结果进行排序。
这将把相关行归类在一起，对于多列索引，将按照索引中列的顺序返回行。清单 15-4 显示了 world.countrylanguage 表索
引的示例。在这种情况下，由于表模式和表名是固定的，因此排序只取决于索引名和索引中的顺序。由于值的性质并不精确，因此
结果可能会有所不同。

#+begin_src sql
  select INDEX_NAME, NON_UNIQUE,
         SEQ_IN_INDEX, COLUMN_NAME,
         CARDINALITY, INDEX_TYPE,
         IS_VISIBLE
  from information_schema.STATISTICS
  where TABLE_SCHEMA='world' and
       TABLE_NAME='countrylanguage'
   order by INDEX_NAME, SEQ_IN_INDEX\G
#+end_src

countrylanguage 表有两个索引。CountryCode 和 Language 列上有一个主键，CountryCode 单独有一个辅助索引。在
mysql.innodb_index_stats 表中，主键被附加到二级非唯一索引的时间也有记录，但 STATISTICS 视图与此不同，不包含
该信息。

#+begin_comment
  由于 CountryCode 列是主键中的第一列，因此仅在 CountryCode 列上使用二级索引是多余的。最佳做法是避免冗余索引。
#+end_comment

您可能希望在统计视图中记录数据，并比较数据随时间的变化情况。突然的变化可能表明数据发生了意外，或者最新的索引统计重
新计算会导致不同的查询计划。

STATISTICS 视图中的某些信息也可通过 SHOW INDEX 语句获得。

** show index语句

SHOW INDEX 语句是获取 MySQL 中索引信息的最初方法。如今，它与 information_schema. STATISTICS（统计）的相同
来源获取数据，因此你可以使用其中任何一种最适合你的方式。STATISTICS 视图的一个主要优点是，你可以选择需要哪些信息以
及如何排序；而使用 SHOW INDEX 语句时，你总是能获得单个表的索引，并根据可用字段进行排序和筛选。

SHOW INDEX 返回的列与 STATISTICS 视图中的列相同，只是省略了表目录、表模式和索引模式。另一方面，SHOW INDEX 可
以选择使用 EXTENDED 关键字，其中包括索引隐藏部分的信息。这不应与不可见索引混淆，而是附加部分，如附加到二级索引中
的主键。标准输出和扩展输出的共同记录信息相同。

清单 15-5 显示了针对 world.city 表的 SHOW INDEX 输出示例（结果假定第 14 章中的索引已被删除）。首先返回标准输
出，然后是扩展输出。由于扩展输出长达数页，因此通过删除部分列和行对其进行了缩写。要查看完整输出，请自行执行语句或查
看本书 GitHub 代码库中的 listing_15_5.txt 文件。

#+begin_src sql
  show index from world.city\G
#+end_src

请注意，列名与统计视图使用的列名并不相同。不过，列的顺序相同，名称相似，因此很容易将这两种输出映射到对方。

在扩展输出中，主键有两个 InnoDB 内部的隐藏列：DB_TRX_ID（6 字节事务标识符）和 DB_ROLL_PTR（7 字节回滚指针，
指向写入回滚段的撤销日志记录）。这两个字段是 InnoDB 多版本支持的一部分。1 在这两个内部字段之后，表中的其余每一列
都会被添加。这表明 InnoDB 对其行使用了聚类索引，因此主键就是行。

对于 CountryCode 的二级索引，主键现在显示为索引的第二部分。这在意料之中，也反映了在 mysql.innodb_index_stats
表中看到的情况。

虽然在研究性能问题时，扩展输出通常不会引起很大兴趣，但在探索 InnoDB 如何工作时，它却很有价值。

INNODB_TABLESTATS 视图是另一个在处理索引统计时非常有用的信息模式视图。

** Information_scheam  INNODB_TABLESTATS 视图

信息模式中的 INNODB_TABLESTATS 视图是 InnoDB 内部内存结构顶部的一个视图，其中包含有关索引的信息。该视图不包
含任何可用于验证索引的卡片性和大小的信息，这些信息没有包含在已经描述过的表和视图中。不过，它可以提供一些索引统计
状态的信息，以及自上次分析表以来的修改次数。该视图包含所有 InnoDB 表的信息，无论它们使用的是持久统计还是瞬时统
计。表 15-4 总结了 INNODB_TABLESTATS 视图的列。

#+NAME: INNODB_TABLESTATS
| 列名              | 数据类型          | 描述                                                                                   |
|------------------+-----------------+---------------------------------------------------------------------------------------|
| TABLE_ID         | bigint unsigned | 内部 InnodB 表 Id。例如，可以用它在 INNODB_ TABLES 信息模式视图中查找表。                     |
| NAME             | varchar(193)    | 表格名称，格式为 <schema>/<table>，例如，world/city。                                      |
| STAT_INITIALIZED | varchar(193)    | 内存结构是否已为表初始化，这与索引统计是否存在不同。                                           |
| NUM_ROWS         | bigint unsigned | 表格中的估计行数。                                                                       |
| CLUST_INDEX_SIZE | bigint unsigned | 聚类索引中的页数。                                                                       |
| OTHER_INDEX_SIZE | bigint unsigned | 二级索引页数的总和。                                                                      |
| MODIFIED_COUNTER | bigint unsigned | 自上次更新索引统计信息以来使用 DML 语句更改的记录数。                                         |
| ATUOINC          | bigint unsigned | 自动递增计数器的值。对于没有自动递增列的表，该值为 0。                                         |
| ERF_COUNT        | int             | 元数据的引用次数。当引用计数器的引用次数为零时，InnodB 可能会驱逐数据，初始化状态也会恢复为未初始化。 |

初始化状态可能会引起混淆。它显示索引统计信息和相关元数据（在此视图中显示）是否已加载到内存中。即使存在统计数据，状
态一开始也总是未初始化。当某个连接或后台线程需要这些数据时，InnoDB 会将其加载到内存中，此时状态就会变成
Initialized。每当没有线程持有对表的引用时，InnoDB 就会再次释放信息，状态也就变成了 "未初始化"。例如，当表被刷新
或对表执行 ANALYZE TABLE 时，就会发生这种情况。

修改计数器很有意思，因为它可以用来查看自上次更新索引统计信息以来有多少行被修改。只有当 DML 查询影响到索引时，计数
器才会增加。这就意味着，如果更新了非索引列，但保持行的原样，计数器就不会增加。该计数器与自动更新有关，当发生一定量
的更改时会触发自动更新。

清单 15-6 是 INNODB_TABLESTATS 视图对 world.city 表的输出示例。如果执行相同的查询，表 ID、行数和引用计数可
能会有所不同。

#+begin_src sql
  select *
  from information_schema.INNODB_TABLESTATS;
#+end_src

输出结果显示，索引统计信息是最新的，因为自上次分析以来没有修改过记录。集群索引和二级索引的行数和大小与使用
mysql.innodb_index_ stats 表找到的相同。这些与表大小相关的数字也用于 information_ schema.TABLES 视图和
SHOW TABLE STATUS 语句。

** information_schema中的TABLES视图和show table status

索引统计信息也用于填充 information_schema.TABLES 视图和 SHOW TABLE STATUS 语句所用表中的某些列。这包括估计
行数以及数据和索引的大小。

表 15-5 显示了 TABLES 视图中列的摘要。SHOW TABLE STATUS 语句的输出中除了 TABLE_CATALOG、TABLE_SCHEMA、
TABLE_TYPE 和 TABLE_COMMENT 列外，其他列都是相同的，有几列的名称略有不同。标有星号 (*) 的列受
information_schema_stats_expiry 变量的影响。

#+NAME: TABLES
| 列名             | 数据类型          | 描述                                                                                                                          |
|-----------------+-----------------+------------------------------------------------------------------------------------------------------------------------------|
| TABLE_CATALOG   | varchar(64)     | 表格所属的目录。                                                                                                                |
| TABLE_SCHEMA    | varchar(64)     | 表格所在的模式。                                                                                                                |
| TABLE_NAME      | varchar(64)     | 表名                                                                                                                          |
| TABLE_TYPE      | enum            | 可能的值有基础表、视图和系统视图。基础表通过 CREATE TABLE 创建，视图通过 CREATE VIEW 创建，系统视图是视图，如 MySQL 创建的信息模式视图。      |
| ENGINE          | varchar(64)     | 表所用存储引擎                                                                                                                  |
| VERSION         | int             | 在 MySQL 8 中未使用，因为它与 MySQL 5.7 及更早版本中的 .frm 文件有关。版本值现在硬编码为 10。                                           |
| ROW_FORMAT      | enum            | 表格使用的行格式。可能的值有Fixed、Dynamic、Compressed、Redundant、Compact和Paged。                                                 |
| TABLE_ROWS      | bigint unsigned | 估计行数。对于 InnodB 表，这来自主键或聚类索引的卡长度。                                                                             |
| AVG_ROW_LENGTH  | bigint unsigned | 估计数据长度除以估计行数。                                                                                                        |
| DATA_LENGTH     | bigint unsigned | 行数据的估计大小。对于 InnodB，它是聚类索引的大小，即聚类索引中的页数乘以页大小。                                                         |
| MAX_DATA_LENGTH | bigint unsigned | 允许的最大数据长度。InnodB 不使用该值，因此该值为 NULL。                                                                             |
| INDEX_LENGTH    | bigint unsigned | 二级索引的估计大小。对于 InnodB，这是非聚类索引中的页面总和乘以页面大小。                                                               |
| DATA_FREE       | bigint unsigned | 表所属表空间中可用空间的估计值。对于 InnodB，这是完全可用的扩展空间大小减去安全系数。                                                     |
| AUTO_INCREMENT  | bigint unsigned | 表格自动递增计数器的下一个值。                                                                                                    |
| CREATE_TIME     | timestamp       | 表创建的时间                                                                                                                   |
| UPDATE_TIME     | datetime        | 表空间文件最后一次更新的时间。对于 InnodB 系统表空间中的表，该值为 NULL。由于数据是异步写入表空间的，因此时间一般不会反映最后一次更改数据的语句的时间。 |
| CHECK_TIME      | datetime        | 上次检查表的时间（CHECK TABLE）。对于分区表，InnodB 总是返回 NULL。                                                                  |
| TABLE_COLLATION | varchar(64)     | 用于对字符串列的值进行排序和比较的默认校对方式（如果没有为列明确设置）。                                                                 |
| CHECKSUM        | bigint          | 表格校验和。InnodB 不使用该值，因此该值为 NULL。                                                                                   |
| CREATE_OPTIONS  | varchar(256)    | 表选项，如 STATS_AUTO_RECALC 和 STATS_SAMPLE_PAGES。                                                                            |
| TABLE_COMMENT   | text            | 创建表格时指定的注释。                                                                                                                             |

在可用信息中，数据和索引的行数和大小与索引统计关系最为密切。TABLES 视图不仅可用于查询表大小的估计值，还可用于查询
哪些表明确设置了持久性统计变量。清单 15-7 显示了一个 chapter_15.t1 表示例，该表填充了整整 100 万行，然后查询了
该表的 TABLES 视图内容。

#+begin_src sql
  create table chapter_15.t1(
    id int unsigned not null auto_increment,
    val varchar(36) not null,
    primary key(id)
  ) STATS_PRESISTENT=1,
    STATS_SAMPLE_PAGES=50,
    STATS_AUTO_RECALC=1;
#+end_src

#+begin_src sql
  set session ctx_max_recursion_depth=1000000;
#+end_src

#+begin_src sql
  start transaction;
  insert into chapter_15.t1(val)
  with recursive seq(i) as (
    select 1
      union all
    select i+1
      from seq where i<1000000
  )
  select uuid() from seq;
  commit;
#+end_src

#+begin_src sql
  select *
    from information_schema.TABLES
    where TABLE_SCHEM='chapter_15'
    and TABLE_NAME='t1'\G
#+end_src

该表使用递归普通表表达式填充随机数据，以确保准确插入 100 万行。为此，有必要将 cte_max_recursion_depth 设置为
1000000，否则普通表表达式会因递归深度过高而失败。

请注意，估计的行数只有 996442 行，比实际行数少了约 0.3%。这在预期范围内--10% 或更大的差异并不罕见。该表还设置了
几个表选项，以明确配置表使用持久统计，并启用自动计算和使用 50 个样本页。

如果希望使用 SHOW TABLE STATUS 语句，可以不带参数地使用该语句，这样就会返回默认模式中所有表的状态。或者，也可以
添加 LIKE 子句，只包含表的子集。要检索非默认模式中表的状态，可使用 FROM 子句指定模式名称。例如，将 "世界 "模式视
为默认模式，那么以下查询都将返回城市表的表状态：

#+begin_src sql
  use world
  show table status like 'city';
  show table status like 'ci%';
  show table status from world like 'city';
#+end_src

前两个查询依赖默认模式来知道在哪里查找表。第三个查询明确地在世界模式中查找城市表。

如果指数统计没有数据了，如何更新？这是本章结束前要探讨的最后一个话题。

** 更新统计

最新的索引统计信息对于优化器获得最佳查询执行计划非常重要。索引更新有两种方式：自动更新，因为表有足够的变化来触发统
计数据的重新计算；手动更新。

** 自动更新

在介绍持久性和瞬时统计时，我们已经在一定程度上讨论了自动更新机制。表 15-6 总结了基于索引统计类型的功能。

#+NAME: InnoDB 索引统计自动重新计算摘要
| 属性                          | 持久                                                  | 暂存                               |
|------------------------------+------------------------------------------------------+-----------------------------------|
| 缓存行                        | 10%的表                                               | 6.25%的表                          |
| 因记录更改而进行更新的最短间隔时间 | 10秒                                                  | 16次更新                           |
| 其他动作触发的更改              |                                                      | 表的首次打开，查询表元数据时可选择使用。 |
| 后台更新                       | 是                                                    | 否                                 |
| 配置                          | innodb_stats_auto_recalc变量和STATS_AUTO_ RECALC表选项 | 空                                 |

总结显示，持久统计数据的更新频率一般较低，影响也较小，因为自动更新是在后台进行的。持久性统计数据也有更好的配置选项。

也可以手动触发索引统计更新。你可以使用 ANALYZE TABLE 语句或 mysqlcheck 命令行程序，这将在接下来的章节中讨论。

** analyze table语句

在使用 mysql 命令行客户端或 MySQL Shell 或由存储过程触发更新时，使用 ANALYZE TABLE 语句非常方便。该语句既可
以更新索引统计信息，也可以更新直方图。后者将在下一章讨论，因此这里只涉及索引统计信息的更新。

ANALYZE TABLE 有一个参数，即是否将语句记录到二进制日志中。如果在 ANALYZE 和 TABLE 之间指定
NO_WRITE_TO_BINLOG 或 LOCAL，语句将只应用于本地实例，而不会写入二进制日志。

执行 ANALYZE TABLE 时，会强制刷新索引统计信息和表缓存值，否则这些值将受制于 information_schema_stats_expiry
变量。因此，如果强制更新了索引统计信息，则无需更改 information_schema_stats_expiry，就能让
information_schema.STATISTICS 视图同样反映更新后的值。

可以选择指定多个表更新其索引统计信息。为此，可以用逗号分隔的列表列出这些表。更新世界模式中三个表的统计信息的示例见
清单 15-8。

#+begin_src sql
  analyze local table
    world.city, world.country,
    world.countrylanguage\G
#+end_src

在示例中，使用 LOCAL 关键字是为了避免将语句记录到二进制日志中。如果不在指定表名的同时指定模式名（例如，用 city
代替 world.city），MySQL 将在当前默认模式中查找表。

#+begin_comment
  虽然可以使用 ANALYZE TABLE 同时查询表，但请注意，作为最后一步（返回客户端后），分析过的表将被刷新（隐式 FLUSH
  TABLES 语句）。表刷新只能在所有正在进行的查询完成后进行，因此在进行长时间查询时，不应使用 ANALYZE TABLE（或
  mysqlcheck）。
#+end_comment

ANALYZE TABLE 语句非常适合临时更新，以及准确知道要分析哪些表的情况。对于分析给定模式中的所有表或实例中的所有表，
它的作用就没那么大了。为此，接下来讨论的 mysqlcheck 是更好的选择。

** mysqlcheck程序

如果你想通过 shell 脚本、cron 守护进程或 Windows 任务调度程序触发更新，那么 mysqlcheck 程序就非常方便。它不仅
可以像 ANALYZE TABLE 那样用于更新单个表或多个表的索引统计信息，还可以让 mysqlcheck 更新模式中所有表或实例中所
有表的索引统计信息。mysqlcheck 所做的是为符合你的条件的表执行 ANALYZE TABLE，因此从索引统计的角度来看，手动执行
ANAYZE TABLE 和使用 mysqlcheck 没有什么区别。

#+begin_comment
  mysqlcheck 程序的功能远不止分析表以更新索引统计。这里只介绍分析功能。要阅读 mysqlcheck 程序的完整文档，请参
  阅 https://dev.mysql.com/doc/refman/en/mysqlcheck.html。
#+end_comment

使用--analyze选项可以让mysqlcheck更新索引统计，而--write-binlog/-skip-write-binlog参数可以告诉你是否
要将语句记录到二进制日志中。默认情况下记录语句。你还需要说明如何连接到 MySQL；为此需要使用标准连接选项。

有三种方法可以指定要分析的表。默认情况下，分析同一模式下的一个或多个表，就像分析 TABLE 语句一样。如果选择这种方式，
就不需要添加任何额外选项，指定的第一个值将被解释为模式名称，可选参数将被解释为表名称。清单 15-9 展示了如何以两种方
式分析世界模式中的所有表：明确列出表名和不列出表名。

如果你想通过 shell 脚本、cron 守护进程或 Windows 任务调度程序触发更新，那么 mysqlcheck 程序就非常方便。它不仅
可以像 ANALYZE TABLE 那样用于更新单个表或多个表的索引统计信息，还可以让 mysqlcheck 更新模式中所有表或实例中所
有表的索引统计信息。mysqlcheck 所做的是为符合你的条件的表执行 ANALYZE TABLE，因此从索引统计的角度来看，手动执行
ANAYZE TABLE 和使用 mysqlcheck 没有什么区别。

#+begin_comment
  mysqlcheck 程序的功能远不止分析表以更新索引统计。这里只介绍分析功能。要阅读 mysqlcheck 程序的完整文档，请参
  阅 https://dev.mysql.com/doc/refman/en/mysqlcheck.html。
#+end_comment
  
使用--analyze选项可以让mysqlcheck更新索引统计，而--write-binlog/-skip-write-binlog参数可以告诉你是否
要将语句记录到二进制日志中。默认情况下记录语句。你还需要说明如何连接到 MySQL；为此需要使用标准连接选项。

有三种方法可以指定要分析的表。默认情况下，分析同一模式下的一个或多个表，就像分析 TABLE 语句一样。如果选择这种方式，
就不需要添加任何额外选项，指定的第一个值将被解释为模式名称，可选参数将被解释为表名称。清单 15-9 展示了如何以两种方
式分析world模式中的所有表：明确列出表名和不列出表名。

#+begin_src sh
  mysqlcheck --user=root --password --host=localhost --port=3306 --analyze world city country countrylanguage
#+end_src

#+begin_src sh
  mysqlcheck --user=root --password --host=localhost --analyze world
#+end_src

在这两种情况下，输出结果都会列出分析过的三个表格。

如果要分析多个模式中的所有表，但仍要列出包括哪些模式，可以使用 --databases 参数。使用该参数时，命令行中列出的所
有对象名称都会被解释为模式名称。清单 15-10 显示了分析 sakila 和 world 模式中所有表的示例。

#+begin_src sh
  mysqlcheck --user=root --password --host=localhost --port=3306 --analyze --database sakila world
#+end_src

最后一个选项是使用 --all-databases 选项来分析所有表，而不管它们位于哪个模式中。除了信息模式和性能模式外，这也包
括系统表。清单 15-11 显示了使用 mysqlcheck 和 --all-databases 的示例。

注意有两张表回复说它们的存储引擎不支持分析。mysqlcheck 程序会尝试分析所有表，而不管它们的存储引擎如何，因此出现示
例中这样的信息是意料之中的。mysql.general_log 和 mysql.slow_log 表默认使用的都是 CSV 存储引擎，它不支持索引，
因此也不支持 ANALYZE TABLE。

** 总结

本章接着上一章的内容，介绍 InnoDB 如何处理索引统计。InnoDB有两种存储统计信息的方式：在
mysql.innodb_index_stats表和mysql.innodb_table_stats表中持久存储，或者在内存中临时存储。一般来说，持
久性统计更受欢迎，因为它们能提供更一致的查询计划，允许对更多页面进行采样，在后台更新，而且可以在更大程度上进行配置，
包括支持表级选项。

有几个表、视图和 SHOW 语句可用于调查和了解 InnoDB 索引及其统计信息。其中，information_schema.STATISTICS 视
图具有 MySQL 中所有索引的详细信息。此外，还讨论了 information_schema.INNODB_TABLESTATS 和
information_schema.TABLES 视图、SHOW INDEX 和 SHOW TABLE STATUS 语句。

更新索引统计信息有两种方法：使用 ANALYZE TABLE 语句或 mysqlcheck 程序。前者适用于交互式客户端或存储过程，而后
者更适用于 shell 脚本和更新一个或多个模式中的所有表。这两种方法都会强制更新 MySQL 数据字典中表元数据和索引卡入度
的缓存值。

在讨论 ANALYZE TABLE 语句时，有人提到 MySQL 还支持直方图。这与索引有关，是下一章的主题。

* 直方图

在前两章中，我们学习了索引和索引统计。索引的目的是减少访问查询所需记录的读取次数，而索引统计则是为了帮助优化器确定
最佳查询计划。这些都很好，但索引并不是免费的，在有些情况下，索引并不十分有效，也不值得花费大量的开销，但优化器仍然
需要了解数据的分布情况。这就是直方图的作用所在。

本章首先讨论什么是直方图以及直方图对哪些工作负载有用。然后介绍直方图的实用性，包括添加、维护和检查直方图数据。最后，
以一个查询为例，说明添加直方图后查询计划会发生哪些变化。

** 直方














