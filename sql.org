* sql


* mariadb
  
** 源码分析
   | 目录          | 说明                                                           |
   |---------------+----------------------------------------------------------------|
   | BUILD         | 内含在各个平台，各种编译器下进行编译的脚本                     |
   | client        | 客户端工具，如mysql, mysqldump, mysqladmin                     |
   | dbug          | 提供一些调试用的宏定义                                         |
   | extra         | 提供innochecksum, resolveip等额外的小工具                      |
   | include       | 包含的头文件                                                   |
   | libmysqld     | 生成libmysqld.so库文件                                         |
   | libservices   | 新加目录，实现了打印功能                                       |
   | man           | 手册页                                                         |
   | mysql-test    | mysqld的测试工具                                               |
   | mysys         | 为跨平台设计，实现了一套常用的数据结构和算法，如string, hash等 |
   | mysys_ssl     | 封装了AES, MD5, SHA等加密算法                                  |
   | pcre          | perl库                                                         |
   | plugin        | mysql以插件形式实现的部分功能                                  |
   | scripts       | 提供脚本工具，如mysql_install_db, mysqld_safe, mysqld_multi    |
   | sql           | mysql主要代码，将会生成mysqld文件，main函数在sql/main.cc里     |
   | sql-bench     | 评测代码                                                       |
   | sql-common    | 存放部分服务器端和客户端都会用到的代码                         |
   | storage       | 存储引擎所在目录，如myisam,innodb,spider等                     |
   | support-files | my.cnf示例配置文件及编译所需的一些工具                         |
   | Tests         | 测试文件所在目录                                               |
   | unittest      | 单元测试文件目录                                               |
   | vio           | 虚拟网络IO处理系统，是对不同平台或不同协议的网络通信API封装    |
   | win           | 在windows平台编译所需的文件和一些说明                          |
   | zlib          | zlib压缩算法库                                                 |

** innodb设计
   
*** 架构设计
    InnoDB存储引擎有多个内存块，可以认为这些内存块组成了一个大的内存池，负责如工作
    1. 维护所有进程/线程需要访问的多个内部数据结构
    2. 缓存磁盘上的数据，方便快速地读取，同时缓存磁盘数据文件之前的修改
    3. 重做日志缓冲


    后台线程的主要作用是负责刷新内存池中的数据，保证缓冲中的内存缓存的是最近的数据，此外将已修改的
    数据文件刷新到磁盘文件，同时保证在数据勯发生异常情况下InnoDB能恢复到正常状态。
    * Master Thread
      主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新，合并插入缓冲，UNOD
      页的回收
    * IO Thread
      负责IO请求的回调处理
    * Purge Thread
      事务提交后，其使用的undolog可能不再需要，因此需要PurgeThread来回收已经使用并分配的undo页
    * Page Cleaner Thread
      之前版本中脏页的刷新操作都放入到单独的线程中完成，减轻原Master Thread的工作及对用户查询线
      程的阻塞，提高引擎的性能


    内存
    * 缓冲池
      是一块内存区域，通过内存的速度来弥补磁盘速度较慢对数据库性能的影响
      读取页操作，首先将从磁盘读到的页存放在缓冲池中，这个过程称为将页"FIX"在缓冲池中，下一次再
      读相同的页时，首先判断该页是否在缓冲池中，若在，则该页被命中，直接读取，否则从磁盘读取
      修改操作，先修改在缓冲池中的页，然后再以一定的频率刷新到磁盘上，页从缓冲池刷新回磁盘的操作
      并不在每次页发生更新时触发，通过Checkpoint机制刷新回磁盘
      缓冲池中缓存的数据页类型有：索引页，数据页，undo页，插入缓冲，自适应哈希索引，InnoDB存储
      的锁信息，数据字典信息等
    * LRU List, Free List和Flush List
      数据库中的缓冲池是通过LRU算法进行管理的，即最频繁使用的页在LRU列表的前端，而最少使用在页
      在LRU列表的尾端，当缓冲池不能存放读取到的新页时，将首先释放LRU列表中的尾端的页
    * 重做缓冲日志
      InnoDB首先将重做日志信息先放入到这个缓冲区，然后按一定频率将其刷新到重做日志文件，只有发
      生如下情况才会进行
      Master Thread 每一秒重做日志缓冲刷新到重做日志文件
      每个事务提交时会将重做日志缓冲刷新到重做日志文件
      当重做日志缓冲剩余空间小于1/2时，重做日志缓冲刷新到重做日志文件
    * 额外的内存池
      对内存管理是通过一种称为内存堆的方法申请，当该区域的内存不够时，会从缓冲池申请


    Checkpoint技术
    InnoDB有两种Checkpoint
    Sharp Checkpoint发生在数据库关闭时将所有的脏页都刷新回磁盘
    Fuzzy Checkpoint则是在运行中使用，只刷新一部分脏页
      


*** 源码目录
    | 目录    | 作用                                                       |
    |---------+------------------------------------------------------------|
    | handler | 继承于MySQL的handler，插件式存储引擎的实现                 |
    | ibuf    | 插入缓冲的实现                                             |
    | include | InnoDB将头文件都统一主在到这个文件夹下                     |
    | lock    | InnoDB存储引擎锁的实现，如S锁，X锁，以及定义锁的一系列算法 |
    | log     | 日志缓冲和重组日志文件的实现。                             |
    | mem     | 辅助缓冲池的实现，用来申请一些数据结构的内存               |
    | mtr     | 事务的底层实现                                             |
    | os      | 封装一些对于操作系统的操作                                 |
    | page    | 页的实现                                                   |
    | row     | 对于各种类型行数据的操作                                   |
    | srv     | 对于InnoDB存储引擎参数的设计                               |
    | sync    | InnoDB存储引擎互斥量的实现                                 |
    | thr     | InnoDB存储引擎封装的可移植的线程库                         |
    | ut      | 工具类                                                     |


   
** 关键技术

*** 插入缓冲   
   1. Insert Buffer
      对于非聚集索引的插入或更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在
      缓冲池中，若在，则直接插入，若不在，则先放入到一个Insert Buffer对象中。数据库这个非聚集索引已
      经插到叶子节点，而实际并没有，只是存放在另一个位置。然后再以一定的频率和情况进行Insert Buffer
      和辅助索引页子节点的merge(节点)操作，这时通常能将多个插入合并到一个操作中，大大提高了对于非聚
      集索引插入的性能。
      Insert Buffer的使用需要同时满足以下两个条件
      索引是辅助索引
      索引不是唯一的
   2. Change Buffer
      可以将其视为Insert Buffer的升级，InnoDB存储引擎可以对DML操作：INSERT，DELETE，UPDATE都进
      行缓冲，分别是：Insert Buffer, Delete Buffer, Purge Buffer
      对一条记录进行UPDATE操作可能分为两个过程
      将记录标记为已删除
      真正将记录删除
      
   
*** 两次写
    doublewrite由两部分组成，一部分是内存中的doublewrite buffer，大小为2MB，另一部分是物理磁盘上
    共享空间中连续的128个页，即2个区(extent)，大小同样为2MB。在对缓冲池的脏页进行刷新时，并不直接写
    磁盘，而是会通过memcopy函数将脏页先复制到内存中的doublewrite buffer，之后通过doublewrite
    buffer再分两次，每次1MB顺序地写入共享表空间的物理磁盘上，然后马上调用fsync函数，同步磁盘，避免
    缓冲写带来的总是，这个过程中，因为doublewrite页是连续的，因此这个过程是顺序的
    
    
*** 异步IO
    用户在发出一个IO请求后立即再发出另一个IO请求，当全部IO请求发送完毕后，等待所有IO操作完成，这是
    AIO。另一个优势是可以进行IO Merge操作，也就是将多个IO合并为1个IO。
    
*** 自适应哈希
    InnoDB存储引擎会临控对表上各索引页的查询。如果观察到建立哈希索引可以带来速度提升，而建立哈希索引，
    称之为自适应哈希索引(Adaptive Hash Index)，AHI是通过缓冲池的B+树页构造而来，因此建立的速度很
    快，而且不需要对整张表构建哈希索引。InnoDB存储引擎会自动根据访问的频率和模式来自动地为某些热点页
    建立哈希索引。
    
*** 刷新邻接页
    当刷新一个脏页时，InnoDB存储引擎会检测该页所在区(extent)的所有页，如果是脏页，那么一起进行刷新，
    通过AIO可以将多个IO写入操作合并为一个IO操作，因此该机制在传统机械磁盘下有着显著的优势。

* sqlite3
** 架构设计
*** 整体设计
   sqlite通过将sql编译成字节码，在虚拟机中运行。sqlite3_prepare_v2()与相关的接口函数把
   sql转换到字节码，sqlite3_stmt对象保存了字节码程序实现单条sql语句。sqlite3_step()通过
   把字节码在虚拟机中运行，直到所有工作完成，或者执行一条语句返回结果。
  
*** 接口
    大多数的C语言接口都在main.c,legacy.c和vbdeapi.c三个文件中。sqlite3_get_table()相关
    实现在table.c文件中，而sqlite3_mprintf()则是在printf.c文件中。sqlite3_complete()实
    现在complete.c中，最后TCL相关接口则是在tclsqlite.c中
    为了避免变量名冲突，所有sqlite3库中相关函数全部使用sqlite3作为前缀。所有开放给外部
    的相关接口函数全部使用sqlite3_作为前缀。插件API有时候添加插件名和下划线，比如
    sqlite3rbu_或sqlite3session_。
*** 分词器
    当一条sqlite语句开始执行时，道先将它发送到分词器。分词器切分sql语句解析为单词，分词
    的相关实现在tokenize.c文件中
    注意在本设计中，分词器实际上就是解析器，可能人们比起其他方法，更熟悉yacc和bison，分
    词器比较解析器更好，因为这是线程安全，而且运行更快
*** 解析器
    解析器使得上文的分词有意义，SQLite的使用Lemon分析器生成，Lemon做的工作和YACC/BISON
    是一样的，但是它使用了不同的输入语法，且它更准确。Lemon生成的分析器同样也是可重用的
    且是线程安全的。Lemon定义了非终端析构函数的概念，为了在语法错误出现时不出现内存泄漏
    ，相关的语法定义文件在parse.y
    因为Lemon是一个开发工具，它的完整代码在SQLite的tools目录下
   
*** 中间代码生成
    在通过解析器把单词转换为解析树，代码生成器会分析解析树，接着会把sql语句转换成中间代
    码运行。sqlite3_stmt对象保存了相关字节码。相关的实现文件有许多attach.c,auth.c,build.c
    delete.c,expr.c,insert.c,pragma.c,select.c,trigger.c,update.c,vacuum.c,where.c,
    wherecode.c以及whereexpr.h。在这些文件中有许多有趣的操作，expr.c为表达式生成中间代码
    where*.c则是为where以及相关的select,update,delete子句生成中间代码。其他的sql语句的
    实现则是在build.c文件中。auth.c文件则实现了sqlite3_set_authorizer()
    在代码生成中，尤其中where*.c逻辑，在select.c中有时候名为query planner。对于任一sql
    语句，可能会有成千上万的不同的算法计算结果。而query planner则是可以从无数种选择中
    找到适合的选择
*** 字节码引擎
    字节码是通过中间代码生成且运行在虚拟机中。虚拟机相关的定义全部在vdbe.c文件中，而vdbe.h
    文件定义了虚拟机与其他sqlite功能之间的接口，而vbdeInt.h则定义了相关的数据结构以及
    虚拟机的相关私有结构，其他的vdbe*.c文件则定义了虚拟机的函数。vdbeaux.c文件则是包含
    相关的工具函数用来构造虚拟机。vdbeapi.c文件是对外的接口，比如sqlite3_bind_int()和
    sqlite3_step()。单个值在内部的对象名为Mem，通过vdbemem.c中实现的。
    sqlite实现sql函数通过回调函数，甚至中内置的sql函数也是如此。大多数sqlite内部函数都能
    在func.c文件中实现。时间和时间的转换函数则是在date.c中实现。一些函数如coalesce()和
    typeof()则是通过中间代码生成字节码生成
*** B-树
    sqlite数据库是通过B-树保存在磁盘上，它的实现保存在btree.c文件中，分隔B-树用来分别保
    存表对象和索引对象。所有的B-树都保存在同一个磁盘文件中。
    B-树子系统的接口和sqlite库定义在btree.h中
*** 页缓存
    B-树模块从磁盘请求固定大小的页。页的默认大小是4096位，它的取值范围在512到65536之间，
    页缓存主要是为了读和写，缓存页，同时也提供回滚和原子提交以及锁住数据库文件。B-树从
    从页缓冲请求特定的页，当请求写入页或提交或回滚时会进入通知，页缓存会处理快速，安全
    高效的处理请求。
    页缓存相关实现在pager.c文件中，WAL模式的逻辑在wal.c文件中，实时缓存实现则是在pcache.c
    和pcache1.c文件。页缓存和其余的相关操作则在pager.h中
*** 操作系统接口
    为了在不同操作系统之间进行移植，SQLite使用了VFS抽象，每个VFS对象提供了打开，读写，
    关闭对磁盘的操作，以及其他特定操作，比如获取当前时间，内置的伪随机数生成器。SQLite
    使用VFSec对接unix和Windows
*** 工具函数
    内存分配，字符串比较函数，数字与字符串之间的转换函数，以及其他的函数保存在util.c中，
    用来保存符号表的hash表实现在hash.c文件，而utf.c文件中则包含字符编码相关的函数。SQLite
    在自己实现的printf()函数在printf.c文件中以及自己实现的伪随机数生成器在random.c中
*** 测试代码
    在src/目录是所有以test打头的文件所有全部是测试文件

** Mutexes设计
   #+begin_src c
     sqlite3_mutex *sqlite3_mutex_alloc(int);
     void sqlite3_mutex_free(sqlite3_mutex*);
     void sqlite3_mutex_enter(sqlite3_mutex*);
     int sqlite3_mutex_try(sqlite3_mutex*);
     void sqlite3_mutex_leave(sqlite3_mutex*);
   #+end_src
   SQLite核心使用这些函数实现线程同步，
