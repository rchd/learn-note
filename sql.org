* sql


* mariadb
  
** 源码分析
   | 目录          | 说明                                                           |
   |---------------+----------------------------------------------------------------|
   | BUILD         | 内含在各个平台，各种编译器下进行编译的脚本                     |
   | client        | 客户端工具，如mysql, mysqldump, mysqladmin                     |
   | dbug          | 提供一些调试用的宏定义                                         |
   | extra         | 提供innochecksum, resolveip等额外的小工具                      |
   | include       | 包含的头文件                                                   |
   | libmysqld     | 生成libmysqld.so库文件                                         |
   | libservices   | 新加目录，实现了打印功能                                       |
   | man           | 手册页                                                         |
   | mysql-test    | mysqld的测试工具                                               |
   | mysys         | 为跨平台设计，实现了一套常用的数据结构和算法，如string, hash等 |
   | mysys_ssl     | 封装了AES, MD5, SHA等加密算法                                  |
   | pcre          | perl库                                                         |
   | plugin        | mysql以插件形式实现的部分功能                                  |
   | scripts       | 提供脚本工具，如mysql_install_db, mysqld_safe, mysqld_multi    |
   | sql           | mysql主要代码，将会生成mysqld文件，main函数在sql/main.cc里     |
   | sql-bench     | 评测代码                                                       |
   | sql-common    | 存放部分服务器端和客户端都会用到的代码                         |
   | storage       | 存储引擎所在目录，如myisam,innodb,spider等                     |
   | support-files | my.cnf示例配置文件及编译所需的一些工具                         |
   | Tests         | 测试文件所在目录                                               |
   | unittest      | 单元测试文件目录                                               |
   | vio           | 虚拟网络IO处理系统，是对不同平台或不同协议的网络通信API封装    |
   | win           | 在windows平台编译所需的文件和一些说明                          |
   | zlib          | zlib压缩算法库                                                 |


   
** Mariadb锁
   latch一般被称为闩锁，因为其要求锁定的时间必须非常短，在InnoDB存储引擎中又可为mutex(互斥量)和
   rwlock(读写锁)，为了保证并发线程操作临界资源的正确性，并且通常没有死锁检测的机制。
   lock的对象是事务，用来锁定的是数据库中对象，如表，页，行。并且一般lock对象仅在事务commit或
   rollback进行释放。
   |          | lock                                | latch                                |
   |----------+-------------------------------------+--------------------------------------|
   | 对象     | 事务                                | 线程                                 |
   | 保护     | 数据库内容                          | 内存数据结构                         |
   | 持续时间 | 整个事务过程                        | 临界资源                             |
   | 模式     | 行锁，表锁，意向锁                  | 读写锁，互斥量                       |
   | 死锁     | 通过waits-for graph, time out等机制 | 无死锁检测与处理机制，仅通过应用程序 |
   |          | 进行死锁检测与处理                  | 加锁的顺序，保证无死锁发生           |
   | 存在于   | Lock Manager的哈希表中              | 每个数据结构的对象中                           |


   锁问题
   1. 脏读
      在不同的事务下，当前事务可以读到另外事务提交的数据。
   2. 不可重复读
      是指在一个事务内多次读取同一数据集合。
   3. 丢失更新
      一个事务的更新操作会被另一个事务的更新操作所覆盖，从而导致数据的不一致。
   4. 死锁
      两个或两个以上的事务在执行过程中，因争执资源而造成的一种互相等待的现象。若无外力作用，事务将无
      法推进下去。

** Mariadb日志
   1. 错误日志
      错误日志记录文件对MariaDB的启动，运行，关闭过程进行了记录，以及所有的错误信息，一些警告或正
      确的信息
   2. 慢查询日志
      在MariaDB启动设置一个阈值，并将运行时间超过该值的所有SQL语句都记录到慢查询日志文件中，该参
      数可以通过long_query_time进行设置
   3. 查询日志
      记录了所有对MariaDB数据库请求的信息，无论这些请求是否得到正确的执行
   4. 二进制日志
      记录了对MariaDB数据库执行更改的所有操作，但不包括SELECT和SHOW这类操作，它的主要作用如下
      恢复，某些数据恢复需要二进制日志
      复制，通过复制和执行二进制日志使一台远程的MariaDB数据库与一台MariaDB进行实时同步
      审计，用户可以通过二进制日志中的信息进行审计，判断是否是攻击
   5. 重做日志
      当实例或介质失败时，InnoDB存储引擎会使用重做日志恢复到掉电前的时刻
   
** Mariadb事务
   事务会把数据库从一种一致状态转换为另一种一致状态，可以确保要么所有修改都已经保存了，要么所有修改都不
   保存
   1. 原子性(atomicity)
      原子性指整个数据库事务不是可分割的工作单位，只有使事务中所有的数据库操作都执行成功，才算整个事务
      成功，事务中任何一个SQL语句执行失败，已经执行成功的SQL语句也必须撤销，数据库状态应该退回到执行
      事务前的状态
   2. 一致性(consistency)
      一致性指事务将数据库从一种状态转变为下一种一致的状态，事务是一致性的单位，如果事务中的某个动作失
      败了，系统可以自动撤销事务－－返回初始化的状态
   3. 隔离性(isolation)
      事务的隔离性要求每个读写事务的对象对其他事务的操作对象能相互离开，即该事务提交前对其他事务都不可
      见，通过使用锁来实现
   4. 持久性(durability)
      事务一旦提交，其结果就是永久性的，即使发生宕机等故障，数据库也能将数据恢复，需要注意，只能从事务
      本身的角度来保证结果的永久性。


*** 事务的实现
   重做日志用来实现事务的持久性，即事务ACID中的D，其中由两部分组成：一是内存中的重做日志缓冲(redo log buffer)
   其是易失的，二是重做日志文件(redo log file)，其是持久的，redo通常是物理日志，记录的是页的物理修改操作，
   undo是逻辑日志，根据每行记录进行记录。
   redo组成
   log block
   [[./images/QXiQxi.png]]


   [[./images/7s8nrT.png]]


   log group为重做日志组，其中有多个重做日志组，只是一个逻辑上的概念，由多个重做日志文件组成，每个log group
   中的日志文件大小是相同的
   重做日志文件中存储的就是之前是在log buffer中保存的log block，因此其也是根据块方式进行物理存储的管理，每个
   块的大小与log block一样，同样为512字节，在InnoDB存储引擎运行过程中，log buffer根据一定的规则将内存中的
   log block刷新到磁盘。
   [[./images/7qkVhD.png]]
   
   重做日志格式
   [[./images/UQ0EMI.png]]

   [[./images/Ls6WEP.png]]

   undo日志设计
   
   
** innodb设计
   
*** 架构设计
    InnoDB存储引擎有多个内存块，可以认为这些内存块组成了一个大的内存池，负责如工作
    1. 维护所有进程/线程需要访问的多个内部数据结构
    2. 缓存磁盘上的数据，方便快速地读取，同时缓存磁盘数据文件之前的修改
    3. 重做日志缓冲


    后台线程的主要作用是负责刷新内存池中的数据，保证缓冲中的内存缓存的是最近的数据，此外将已修改的
    数据文件刷新到磁盘文件，同时保证在数据勯发生异常情况下InnoDB能恢复到正常状态。
    * Master Thread
      主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新，合并插入缓冲，UNOD
      页的回收
    * IO Thread
      负责IO请求的回调处理
    * Purge Thread
      事务提交后，其使用的undolog可能不再需要，因此需要PurgeThread来回收已经使用并分配的undo页
    * Page Cleaner Thread
      之前版本中脏页的刷新操作都放入到单独的线程中完成，减轻原Master Thread的工作及对用户查询线
      程的阻塞，提高引擎的性能


    内存
    * 缓冲池
      是一块内存区域，通过内存的速度来弥补磁盘速度较慢对数据库性能的影响
      读取页操作，首先将从磁盘读到的页存放在缓冲池中，这个过程称为将页"FIX"在缓冲池中，下一次再
      读相同的页时，首先判断该页是否在缓冲池中，若在，则该页被命中，直接读取，否则从磁盘读取
      修改操作，先修改在缓冲池中的页，然后再以一定的频率刷新到磁盘上，页从缓冲池刷新回磁盘的操作
      并不在每次页发生更新时触发，通过Checkpoint机制刷新回磁盘
      缓冲池中缓存的数据页类型有：索引页，数据页，undo页，插入缓冲，自适应哈希索引，InnoDB存储
      的锁信息，数据字典信息等
    * LRU List, Free List和Flush List
      数据库中的缓冲池是通过LRU算法进行管理的，即最频繁使用的页在LRU列表的前端，而最少使用在页
      在LRU列表的尾端，当缓冲池不能存放读取到的新页时，将首先释放LRU列表中的尾端的页
    * 重做缓冲日志
      InnoDB首先将重做日志信息先放入到这个缓冲区，然后按一定频率将其刷新到重做日志文件，只有发
      生如下情况才会进行
      Master Thread 每一秒重做日志缓冲刷新到重做日志文件
      每个事务提交时会将重做日志缓冲刷新到重做日志文件
      当重做日志缓冲剩余空间小于1/2时，重做日志缓冲刷新到重做日志文件
    * 额外的内存池
      对内存管理是通过一种称为内存堆的方法申请，当该区域的内存不够时，会从缓冲池申请


    Checkpoint技术
    InnoDB有两种Checkpoint
    Sharp Checkpoint发生在数据库关闭时将所有的脏页都刷新回磁盘
    Fuzzy Checkpoint则是在运行中使用，只刷新一部分脏页
      


*** 源码目录
    | 目录    | 作用                                                       |
    |---------+------------------------------------------------------------|
    | handler | 继承于MySQL的handler，插件式存储引擎的实现                 |
    | ibuf    | 插入缓冲的实现                                             |
    | include | InnoDB将头文件都统一主在到这个文件夹下                     |
    | lock    | InnoDB存储引擎锁的实现，如S锁，X锁，以及定义锁的一系列算法 |
    | log     | 日志缓冲和重组日志文件的实现。                             |
    | mem     | 辅助缓冲池的实现，用来申请一些数据结构的内存               |
    | mtr     | 事务的底层实现                                             |
    | os      | 封装一些对于操作系统的操作                                 |
    | page    | 页的实现                                                   |
    | row     | 对于各种类型行数据的操作                                   |
    | srv     | 对于InnoDB存储引擎参数的设计                               |
    | sync    | InnoDB存储引擎互斥量的实现                                 |
    | thr     | InnoDB存储引擎封装的可移植的线程库                         |
    | ut      | 工具类                                                     |



*** 表结构
    表空间是InnoDB存储引擎逻辑结构的最高层，所有数据都存放在表空间中，表空间又由段，区，页组成，页在
    一些文档中有时也称为块
    表空间由各个段组成，常见的段有数据段，索引段，回滚段等，
    区是由连续页组成的空间，在任何情况下每个区的大小都为1MB，为了保证区中页的连续性，InnoDB存储引擎
    一次从磁盘申请4-5个区。在默认情况下，InnoDB存储引擎页的大小为16KB，即一个区中一共有64个连续的页
    页是InnoDB磁盘管理的最小单位，在InnoDB存储引擎中，常见的页类型有数据页(B-tree Node)，undo页
    (undo Log Page)，系统页(System Page)，事务数据页(Transaction system Page)，插入缓冲位
    图页(Insert Buffer Bitmap)，未压缩的二进制大对象页(Uncompressed BLOB Page)，压缩的二进
    制大对象页(compressed BLOB Page)
    行，InnoDB是面向列的，也就是说按行进行存放的，每个页存放的行记录也是有硬性规定，最多存放
    16KB/2-200记录，即7992行

** 关键技术

*** 插入缓冲   
   1. Insert Buffer
      对于非聚集索引的插入或更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在
      缓冲池中，若在，则直接插入，若不在，则先放入到一个Insert Buffer对象中。数据库这个非聚集索引已
      经插到叶子节点，而实际并没有，只是存放在另一个位置。然后再以一定的频率和情况进行Insert Buffer
      和辅助索引页子节点的merge(节点)操作，这时通常能将多个插入合并到一个操作中，大大提高了对于非聚
      集索引插入的性能。
      Insert Buffer的使用需要同时满足以下两个条件
      索引是辅助索引
      索引不是唯一的
   2. Change Buffer
      可以将其视为Insert Buffer的升级，InnoDB存储引擎可以对DML操作：INSERT，DELETE，UPDATE都进
      行缓冲，分别是：Insert Buffer, Delete Buffer, Purge Buffer
      对一条记录进行UPDATE操作可能分为两个过程
      将记录标记为已删除
      真正将记录删除
      
   
*** 两次写
    doublewrite由两部分组成，一部分是内存中的doublewrite buffer，大小为2MB，另一部分是物理磁盘上
    共享空间中连续的128个页，即2个区(extent)，大小同样为2MB。在对缓冲池的脏页进行刷新时，并不直接写
    磁盘，而是会通过memcopy函数将脏页先复制到内存中的doublewrite buffer，之后通过doublewrite
    buffer再分两次，每次1MB顺序地写入共享表空间的物理磁盘上，然后马上调用fsync函数，同步磁盘，避免
    缓冲写带来的总是，这个过程中，因为doublewrite页是连续的，因此这个过程是顺序的
    
    
*** 异步IO
   用户在发出一个IO请求后立即再发出另一个IO请求，当全部IO请求发送完毕后，等待所有IO操作完成，这是
    AIO。另一个优势是可以进行IO Merge操作，也就是将多个IO合并为1个IO。
    
*** 自适应哈希
    InnoDB存储引擎会临控对表上各索引页的查询。如果观察到建立哈希索引可以带来速度提升，而建立哈希索引，
    称之为自适应哈希索引(Adaptive Hash Index)，AHI是通过缓冲池的B+树页构造而来，因此建立的速度很
    快，而且不需要对整张表构建哈希索引。InnoDB存储引擎会自动根据访问的频率和模式来自动地为某些热点页
    建立哈希索引。
    
*** 刷新邻接页
    当刷新一个脏页时，InnoDB存储引擎会检测该页所在区(extent)的所有页，如果是脏页，那么一起进行刷新，
    通过AIO可以将多个IO写入操作合并为一个IO操作，因此该机制在传统机械磁盘下有着显著的优势。

* sqlite3
** 架构设计
*** 整体设计
   sqlite通过将sql编译成字节码，在虚拟机中运行。sqlite3_prepare_v2()与相关的接口函数把
   sql转换到字节码，sqlite3_stmt对象保存了字节码程序实现单条sql语句。sqlite3_step()通过
   把字节码在虚拟机中运行，直到所有工作完成，或者执行一条语句返回结果。
  
*** 接口
    大多数的C语言接口都在main.c,legacy.c和vbdeapi.c三个文件中。sqlite3_get_table()相关
    实现在table.c文件中，而sqlite3_mprintf()则是在printf.c文件中。sqlite3_complete()实
    现在complete.c中，最后TCL相关接口则是在tclsqlite.c中
    为了避免变量名冲突，所有sqlite3库中相关函数全部使用sqlite3作为前缀。所有开放给外部
    的相关接口函数全部使用sqlite3_作为前缀。插件API有时候添加插件名和下划线，比如
    sqlite3rbu_或sqlite3session_。
*** 分词器
    当一条sqlite语句开始执行时，道先将它发送到分词器。分词器切分sql语句解析为单词，分词
    的相关实现在tokenize.c文件中
    注意在本设计中，分词器实际上就是解析器，可能人们比起其他方法，更熟悉yacc和bison，分
    词器比较解析器更好，因为这是线程安全，而且运行更快
*** 解析器
    解析器使得上文的分词有意义，SQLite的使用Lemon分析器生成，Lemon做的工作和YACC/BISON
    是一样的，但是它使用了不同的输入语法，且它更准确。Lemon生成的分析器同样也是可重用的
    且是线程安全的。Lemon定义了非终端析构函数的概念，为了在语法错误出现时不出现内存泄漏
    ，相关的语法定义文件在parse.y
    因为Lemon是一个开发工具，它的完整代码在SQLite的tools目录下
   
*** 中间代码生成
    在通过解析器把单词转换为解析树，代码生成器会分析解析树，接着会把sql语句转换成中间代
    码运行。sqlite3_stmt对象保存了相关字节码。相关的实现文件有许多attach.c,auth.c,build.c
    delete.c,expr.c,insert.c,pragma.c,select.c,trigger.c,update.c,vacuum.c,where.c,
    wherecode.c以及whereexpr.h。在这些文件中有许多有趣的操作，expr.c为表达式生成中间代码
    where*.c则是为where以及相关的select,update,delete子句生成中间代码。其他的sql语句的
    实现则是在build.c文件中。auth.c文件则实现了sqlite3_set_authorizer()
    在代码生成中，尤其中where*.c逻辑，在select.c中有时候名为query planner。对于任一sql
    语句，可能会有成千上万的不同的算法计算结果。而query planner则是可以从无数种选择中
    找到适合的选择
*** 字节码引擎
    字节码是通过中间代码生成且运行在虚拟机中。虚拟机相关的定义全部在vdbe.c文件中，而vdbe.h
    文件定义了虚拟机与其他sqlite功能之间的接口，而vbdeInt.h则定义了相关的数据结构以及
    虚拟机的相关私有结构，其他的vdbe*.c文件则定义了虚拟机的函数。vdbeaux.c文件则是包含
    相关的工具函数用来构造虚拟机。vdbeapi.c文件是对外的接口，比如sqlite3_bind_int()和
    sqlite3_step()。单个值在内部的对象名为Mem，通过vdbemem.c中实现的。
    sqlite实现sql函数通过回调函数，甚至中内置的sql函数也是如此。大多数sqlite内部函数都能
    在func.c文件中实现。时间和时间的转换函数则是在date.c中实现。一些函数如coalesce()和
    typeof()则是通过中间代码生成字节码生成
*** B-树
    sqlite数据库是通过B-树保存在磁盘上，它的实现保存在btree.c文件中，分隔B-树用来分别保
    存表对象和索引对象。所有的B-树都保存在同一个磁盘文件中。
    B-树子系统的接口和sqlite库定义在btree.h中
*** 页缓存
    B-树模块从磁盘请求固定大小的页。页的默认大小是4096位，它的取值范围在512到65536之间，
    页缓存主要是为了读和写，缓存页，同时也提供回滚和原子提交以及锁住数据库文件。B-树从
    从页缓冲请求特定的页，当请求写入页或提交或回滚时会进入通知，页缓存会处理快速，安全
    高效的处理请求。
    页缓存相关实现在pager.c文件中，WAL模式的逻辑在wal.c文件中，实时缓存实现则是在pcache.c
    和pcache1.c文件。页缓存和其余的相关操作则在pager.h中
*** 操作系统接口
    为了在不同操作系统之间进行移植，SQLite使用了VFS抽象，每个VFS对象提供了打开，读写，
    关闭对磁盘的操作，以及其他特定操作，比如获取当前时间，内置的伪随机数生成器。SQLite
    使用VFSec对接unix和Windows
*** 工具函数
    内存分配，字符串比较函数，数字与字符串之间的转换函数，以及其他的函数保存在util.c中，
    用来保存符号表的hash表实现在hash.c文件，而utf.c文件中则包含字符编码相关的函数。SQLite
    在自己实现的printf()函数在printf.c文件中以及自己实现的伪随机数生成器在random.c中
*** 测试代码
    在src/目录是所有以test打头的文件所有全部是测试文件

