* 软件管理命令
 
  | 命令                | 说明             |
  |---------------------+------------------|
  | pkg info            | 显示已安装的软件 |
  | pkg install package | 安装软件         |
  | pkg search package  | 搜索软件包       |
  | pkg delete package  | 删除软件包       |
  | pkg autoremove      | 删除相关依赖     |
  |                     |                  |

  
** 系统更新
   #+begin_src sh
     freebsd-update fetch install  # 更新软件包
     freebsd-update upgrade -r system-version # 更新系统
   #+end_src


* 内核功能
  与硬件无关的功能
  * 基本的内核功能:定时器和系统时钟处理机制，描述符管理，以及进程管理
  * 支持内存管理：调页(paging)和交换(swapping)机制
  * 通用系统接口: I/O，控制，在描述符上执行的多重复用(multiplexing)操作
  * 文件系统: 文件，目录，路径名转换，文件加锁以及I/O缓冲管理
  * 终端处理: 伪终端(pseudo-terminal)接口和终端行规程(line discipline)
  * 进程间通信功能: 套接口(socket)
  * 支持网络通信: 通信协议和基本网络功能


  与硬件相关的代码
  * 底层的系统启动动作
  * 陷阱(trap)和出错的处理
  * 进程在运行时刻(run-time)上下文的底层操作
  * 对硬件设备的配置和初始化
  * 对I/O设备在运行时刻的支持


* 源代码分析

  
** 启动分析
   freebsd的入口函数在sys/kern/init_main.c中，命名为mi_startup()，该函数主要是把所有的SYSINIT模块全部加载到
   内存，它通过比较subsystem和order进行排序，接着依次调用相关的初始化函数
   基本服务
   | 模块                    | 第一个例程               |
   |-------------------------+--------------------------|
   | SI_SUB_MTX_POOL_STATIC  | mtx_pool_setup()         |
   | SI_SUB_LOCKMGR          | lockngr_init()           |
   | SI_SUB_VM               | vm_mem_init()            |
   | SI_SUB_KMEM             | kmeminit()               |
   | SI_SUB_KVM_RSRC         | vmrnapentry_rsrc_init()  |
   | SI_SUB_WITNESS          | witness_initialize()     |
   | SI_SUB_MTX_POOL_DYNAMIC | mtx_pool_setup_dynamic() |
   | SI_SUB_LOCK()           | selectinit()             |
   | SI_SUB_EVENTHANDLER     | eventhandler_init()      |
   | SI_SUB_KLD              | linker_init()            |
   | SI_SUB_CPU              | cpu_startup()                         |

   初始化内核进程
   | 模块                 | 第一个例程       |
   |----------------------+------------------|
   | SI_SUB_INTRINSIC     | proc0_init()     |
   | SI_SUB_VM_CONF       | vm_init_limits() |
   | SI_SUB_RUN_QUEUE     | runq_init()      |
   | SI_SUB_KTRACE        | ktrace_init()    |
   | SI_SUB_CREATE_INIT   | create_init()    |
   | SI_SUB_SCHED__IDLE() | idle_setup()     |

   初始化设备模块
   | 模块            | 第一个例程                       |
   |-----------------+----------------------------------|
   | SI_SUB_MBUF     | mbuf_init()                      |
   | SI_SUB_INTR     | intr_init()                      |
   | SI_SUB_SOFTINTR | start_softintr(), start_netisr() |
   | SI_SUB_DEVFS    | devry_init(), devs_set_ready()   |
   | SI_SUB_INIT_IF  | if_init()                        |
   | SI_SUB_DRIVERS  |                                  |
   | SI_SUBCONFIGURE | configure_first()                |
   | SI_SUB_VFS      | vfsinit()                        |
   | SI_SUB_CLOCKS   | initclocks()                     |
   | SI_SUB_CLIST    | clist_init()                     |

   启动进程间通信
   | 模块                        | 第一个例程        |
   |-----------------------------+-------------------|
   | SI_SUB_SYSV_SEM             | sysvsem_modload() |
   | SI_SUB_SYSV_SHM             | sysvshm_modload() |
   | SI_SUB_SYSV_MSG             | sysvmsg_modload() |
   | SI_SUB_PROTO_IF             | if_check()        |
   | SI_SUB_PROTO_DOMAIN         | domaininit()      |
   | SI_SUB_PROTO_IFATTACHDOMAIN | if_attachdomain() |

   启动内核线程
   | 模块                  | 第一个例程    |
   |-----------------------+---------------|
   | SI_SUB_INTRINSIC_POST | proc0_post()  |
   | SI_SUB_KTHREAD_INIT   | kick_init()   |
   | SI_SUB_KTHREAD_PAGE   | vm_pageout()  |
   | SI_SUB_KTHREAD_VM     | vm_daemon()   |
   | SI_SUB_KTHREAD_BUF    | buf_daemon()  |
   | SI_SUB_KTHREAD_UPDATE | vnlru_proc()  |
   | SI_SUB_KTHREAD_IDLE   | ald_daemon()  |
   | SI_SUB_SMP            | release_aps() |
   | SI_SUB_RUN_SCHEDULER  | scheduler()              |

   
** 获取源代码
   #+begin_src sh
     cd /usr/src && \
	 svnlite checkout https://svn.freebsd.org/base/head .
   #+end_src
   
** 编译安装内核
   构建环境
   #+begin_src sh
   cp sys/amd64/conf/GENERIC  ./MYKERNEL
   make buildworld KERNCONF=MYKERNEL -DNO_CLEAN
   #+end_src
   编译内核
   #+begin_src sh
   make buildkernel KERNCONF=UFFIE -DNO_CLEAN
   #+end_src
   安装环境及内核
   #+begin_src sh
   sudo make installworld KERNCONF=MYKERNEL
   sudo make installkernel KERNCONF=MYKERNEL
   #+end_src

** 源码目录
   | 目录       | 作用                        |
   |------------+-----------------------------|
   | /bin       | /bin下程序的源码            |
   | /etc       | /etc目录的配置文件          |
   | /include   | /usr/include系统API的头文件 |
   | /kerberos5 | kerberos5框架的源代码       |
   | /lib       | /usr/lib下的库代码          |
   | /libexec   | /usr/libexec程序源码        |
   | /sbin      | /sbin程序源码               |
   | /sys       | 内核源码                    |
   | /usr.bin   | /usr/bin下程序源码          |
   | /usr.sbin  | /usr/sbin下程序源码         |
   | /tests     | freebsd测试用例             |
   | /share     | /usr/share帮助目录          |
   | /contrib   | 第三方程序源码              |
   | /crypto    | 相关的加密解密程序          |
   | /gnu       | GPL声明                     |
   | /release   | 构建freebsd的配置文件                |
   |            |                             |

* 编程
  
** kqueue模型
   kqueue是BSD中使用的内核事件通知机制，一个kqueue指的是一个描述符，这个描述符会塞等待直到一个特定类型
   和种类的事件发生。用户态的进程(或内核)可以等待这个描述符，因而kqueue提供一种用于一个或多进程同步的
   简单而高效的方法
   kqueue和对应的kevent(表示事件的数据结构)构成了内核异步I/O的基础(因此也实现了POSIX的poll(2)/select(2))
   在用户态，简单地调用kqueue(2)系统调用就可以创建一个kqueue，不需要传任何参数。通过EV_SET宏设置指定事件
   即初始化kevent结构体，调用kevent(2)或kevent64(2)系统调用设置事件过滤器，如果满足过滤器的话则返回(否则
   阻塞)。系统支持一些"预定义"的过滤器
   | 事件过滤器      | 用途                                                                  |
   |-----------------+-----------------------------------------------------------------------|
   | EVFILT_MACHPORT | 监视一个Mach port或一个port组，如果监视的port接收到了一条消息，则返回 |
   | EVILT_PROC      | 监视一个指定PID表示的进程调用execve(2),exit(2),fork(2),wait(2)或      |
   |                 | 被发送信号等事件                                                      |
   | EVFILT_READ     | 如果监视文件，那么当文件指针没有在EOF时返回                           |
   |                 | 如果监视套接字，管道或FIFO，那么当有数据可读时就返回                  |
   | EVFILT_SESSION  | 监视一个审计会话                                                      |
   | EVFILT_SIGNAL   | 监控发给一个进程的特定信号，即使这个信号衩进程忽略                    |
   | EVFILT_TIMER    | 最高能达到纳秒精确度周期定时器                                        |
   | EVFILT_WRITE    | 如果监视文件，那么当文件可以写入时返回                                |
   |                 | 如果监视套接字，管道或FIFO，那么当数据可写入返回                      |
   | EVFILT_VM       | 虚拟内存相关的通知                                                    |
   | EVFILT_VNODE    | 文件(vnode)相关系统调用的过滤器，例如rename(2), delete(2), unlink(2)  |

   通过kevent跟踪某个PID表示的进程的进程级别示例
   #+begin_src c
     void main(int arvc, char **argv)
     {
       pid_t pid;
       int kq;
       int rc;
       int done;
       struct kevent ke;

       pid = atoi(argv[1]);

       kq = kqueue();

       if(kq == -1) { perror("kqueue"); exit(2); }

       EV_SET(&ke, pid, EVFILT_PROC, EV_ADD,
	      NOTE_EXIT | NOTE_FORK | NOTE_EXEC, 0, NULL);

       rc = kevent(kq, &ke, 1, NULL, 0, NULL);
       if(rc < 0) { perror("kevent"); exit(3);}

       done = 0;
       while(!done){
	 memset(&ke, '\0', 1, NULL, 0, NULL);

	 rc = kevent(kq, NULL, 0, &ke, 1, NULL);
	 if(rc < 0) { perror("kevent"); exit(4); }

	 if(ke.fflags & NOTE_FORK)
	   printf("PID %d fork()end\n", ke.ident);

	 if(ke.fflags & NOTE_EXEC)
	   printf("pid %d has exec()ed\n", ke.ident);

	 if(ke.fflags & NOTE_EXIT){
	   printf("pid %d has exited\n", ke.ident);
	   done++;
	 }
       }
     }

	
  

   #+end_src
   

   

